<?xml version="1.0"?><st-source><!-- Name: PrologNotice: Licensed under the MIT license.Copyright (c) 2018 - Martial TarizzoPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.BundleName: PrologBundleStructure: a Store.BundleForParcelComment: ======================================================================||   Prolog interpreter written in Smalltalk|======================================================================From the initial Goodies for VisualWorks 2.5/2.5J and VisualWave 1.0Copyright (C) 1995-1997 AOKI Atsushi1997/02/21======================================================================Adapted from GNU Smalltalk| Written by Aoki Atsushi and Nishihara Satoshi.| Modified by Paolo Bonzini (removed GUI).======================================================================Modified for VW 7.10 - Martial TarizzoPackages- PrologCore (core classes, nearly same as GNU, some minor modifications)- PrologShell : GUI“Prolog In Smalltalk” (PiS) is a processing system (interpreter) of Prolog conforming to Dec-10 Prolog notation. Everything in PiS is prefix notation, prefix / infix / postfix with op predicates cannot be defined.The Prolog bundle contains two packages:•  PrologCore•  PrologShell PrologCore is the main package, containing 15 classes. The main class is the interpreter (PrologInterpreter) with two public methods (refute: and refute:action:)A very simple GUI is in the package PrologShell. A subclass of PrologInterpreter (PrologShellInterpreter) is used as an example of interaction between Prolog and VisualWorks.See packages comment for details.See also:https://github.com/MartialTarizzo/Prolog-in-Smalltalkwhere a documentation is available ( "Prolog In Smalltalk - documentation.pdf" ) To test :((((Prolog.PrologShell open)))DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' ''))Parcel: nilParcelName: PrologPrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle))PrerequisiteParcels: #(#('Base VisualWorks' '') #('Base VisualWorks' ''))Version: 1.19Date: 8:55:24 AM January 4, 2019 --><time-stamp>From VisualWorks® Personal Use Edition, 7.10 of 10 juillet 2013 on 4 janvier 2019 at 08:55:24</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Prolog</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>PrologCore</package></attributes></name-space><class><name>PrologEntity</name><environment>Prolog</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><class><name>PrologList</name><environment>Prolog</environment><super>Prolog.PrologEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>carPart cdrPart </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><class><name>PrologClause</name><environment>Prolog</environment><super>Prolog.PrologList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><class><name>PrologString</name><environment>Prolog</environment><super>Prolog.PrologEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string </inst-vars><class-inst-vars>charMap </class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><class><name>PrologVariable</name><environment>Prolog</environment><super>Prolog.PrologString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><class><name>PrologDefinition</name><environment>Prolog</environment><super>Prolog.PrologList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><class><name>PrologInterpreter</name><environment>Prolog</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>systemPredicates userPredicates status definition question questionEnv clause clauseEnv queue queueEnv envCounter valueEnv unbindList cutBack backTrack resolveAction definitionStack tracePredicates traceCounter textValue textCollector verbose listValue predicate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><class><name>PrologShellInterpreter</name><environment>Prolog</environment><super>Prolog.PrologInterpreter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PrologShell</package></attributes></class><class><name>PrologResolveClause</name><environment>Prolog</environment><super>Prolog.PrologClause</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><class><name>PrologEditorController</name><environment>Prolog</environment><super>UI.TextEditorController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastFileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PrologShell</package></attributes></class><class><name>PrologSymbol</name><environment>Prolog</environment><super>Prolog.PrologString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><class><name>PrologShell</name><environment>Prolog</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outputText inputText prologInterpreter mustEvalCell prologProcess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PrologShell</package></attributes></class><comment><class-id>Prolog.PrologShell</class-id><body>PrologShell is the GUI in Smalltalk to interact with a PrologInterpreter.Try :((( Prolog.PrologShell open)))to open a shell with a PrologShellInterpreter instance as interpreter(((Prolog.PrologShell openWith: PrologInterpreter new)))to open a shell with a default PrologInterpreter instance as interpreterTo ease development within Smalltalk, the contents of the editor buffer is saved in a PrologShell class variable each time an evaluation is done. When you restart the shell, the old contents automagically reappears !Instance Variables	inputText	&lt;ValueModel&gt;	Editor text	mustEvalCell	&lt;Boolean&gt;	used to know when to eval a cell	outputText	&lt;TextCollector&gt;	output text collector	prologInterpreter	&lt;PrologInterpreter&gt;	The current prologInterpreter</body></comment><class><name>PrologBody</name><environment>Prolog</environment><super>Prolog.PrologList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><class><name>PrologScanner</name><environment>Prolog</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source mark token tokenType endChar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><class><name>PrologTerms</name><environment>Prolog</environment><super>Prolog.PrologList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><class><name>PrologObject</name><environment>Prolog</environment><super>Prolog.PrologEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><class><name>PrologParser</name><environment>Prolog</environment><super>Prolog.PrologScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>prevMark prevToken prevTokenType failBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><class><name>PrologStructure</name><environment>Prolog</environment><super>Prolog.PrologList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Examples-Prolog</category><attributes><package>PrologCore</package></attributes></class><shared-variable><name>ScanningTable</name><environment>Prolog.PrologScanner</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PrologCore</package></attributes></shared-variable><shared-variable><name>EndChar</name><environment>Prolog.PrologScanner</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PrologCore</package></attributes></shared-variable><shared-variable><name>PrologDotPairPrintHorizontalLevel</name><environment>Prolog.PrologList</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PrologCore</package></attributes></shared-variable><shared-variable><name>PrologDotPairPrintVerticalLevel</name><environment>Prolog.PrologList</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PrologCore</package></attributes></shared-variable><shared-variable><name>PrologVar</name><environment>Prolog.PrologSymbol</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PrologCore</package></attributes></shared-variable><shared-variable><name>PrologSelf</name><environment>Prolog.PrologSymbol</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PrologCore</package></attributes></shared-variable><shared-variable><name>PrologFail</name><environment>Prolog.PrologSymbol</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PrologCore</package></attributes></shared-variable><shared-variable><name>PrologTrue</name><environment>Prolog.PrologSymbol</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PrologCore</package></attributes></shared-variable><shared-variable><name>PrologSymbolTable</name><environment>Prolog.PrologSymbol</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PrologCore</package></attributes></shared-variable><shared-variable><name>PrologCut</name><environment>Prolog.PrologSymbol</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PrologCore</package></attributes></shared-variable><shared-variable><name>PrologSend</name><environment>Prolog.PrologSymbol</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PrologCore</package></attributes></shared-variable><shared-variable><name>PrologVariableCounter</name><environment>Prolog.PrologVariable</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PrologCore</package></attributes></shared-variable><shared-variable><name>PrologVariableTable</name><environment>Prolog.PrologVariable</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PrologCore</package></attributes></shared-variable><shared-variable><name>LastPrologBuffer</name><environment>Prolog.PrologShell</environment><private>false</private><constant>false</constant><category>initialize-release</category><initializer>String new</initializer><attributes><package>PrologShell</package></attributes></shared-variable><methods><class-id>Prolog.PrologEntity</class-id> <category>testing</category><body package="PrologCore">isPrologEntity    ^true</body></methods><methods><class-id>Prolog.PrologList</class-id> <category>functions</category><body package="PrologCore">append: aPrologDotPair     (cdrPart consp)	ifFalse: [^carPart cons: aPrologDotPair].    ^carPart cons: (cdrPart append: aPrologDotPair)</body><body package="PrologCore">arity    ^2</body><body package="PrologCore">assoc: anObject     | list assoc |    list := self.    [list consp]	whileTrue: 	    [assoc := list car.	    anObject = assoc car ifTrue: [^assoc].	    list := list cdr].    ^nil</body><body package="PrologCore">functor    ^PrologSymbol fromString: '.'</body><body package="PrologCore">length    | list count |    list := self.    count := 0.    [list consp]	whileTrue: 	    [count := count + 1.	    list := list cdr].    ^count</body><body package="PrologCore">member: anObject     | list |    list := self.    [list consp]	whileTrue: 	    [anObject = list car ifTrue: [^list].	    list := list cdr].    ^nil</body><body package="PrologCore">nconc: aPrologDotPair     | list |    list := self.    [list consp]	whileTrue: [(list cdr consp)		ifTrue: [list := list cdr]		ifFalse: 		    [list cdr: aPrologDotPair.		    ^self]].    ^aPrologDotPair</body><body package="PrologCore">reverse    | list revlist mark |    list := self.    revlist := nil.    [list consp]	whileTrue: 	    [revlist == nil		ifTrue: [revlist := mark := list car cons: revlist]		ifFalse: [revlist := list car cons: revlist].	    list := list cdr].    mark cdr: list.    ^revlist</body><body package="PrologCore">structureList    "disassemble prolog structure of myself into a list."    ^self functor cons: ((self car) cons: ((self cdr) cons: nil))</body></methods><methods><class-id>Prolog.PrologList</class-id> <category>testing</category><body package="PrologCore">= anObject     anObject consp ifFalse: [^false].    self car = anObject car ifTrue: [^self cdr = anObject cdr].    ^false</body><body package="PrologCore">consp    ^true</body></methods><methods><class-id>Prolog.PrologList</class-id> <category>printing</category><body package="PrologCore">prettyPrintPrologOn: aStream     | head body list |    head := self car.    body := self cdr.    head printPrologOn: aStream.    body ~~ nil	ifTrue: 	    [aStream nextPutAll: ' :- '.	    list := body.	    aStream nl; tab.	    [list cdr consp]		whileTrue: 		    [list ~~ body			ifTrue: 			    [aStream nextPutAll: ', '.			    aStream cr; tab].		    list car printPrologOn: aStream.		    list := list cdr].	    list ~~ self		ifTrue: 		    [aStream nextPutAll: ', '.		    aStream cr; tab].	    list car printPrologOn: aStream].    aStream nextPut: $.</body><body package="PrologCore">prettyPrintPrologString    | aStream |    aStream := WriteStream on: (String new: 20).    self prettyPrintPrologOn: aStream.    ^aStream contents</body><body package="PrologCore">printOn: aStream     aStream nextPutAll: self class printString.    aStream nextPutAll: '('.    aStream nextPutAll: self printPrologString.    aStream nextPutAll: ')'</body><body package="PrologCore">printPrologOn: aStream     self printPrologOn: aStream level: 1</body><body package="PrologCore">printPrologOn: aStream cdr: tail level: anInteger     | d count |    d := tail.    count := 1.    [d consp]	whileTrue: 	    [count &gt;= PrologDotPairPrintHorizontalLevel		ifTrue: 		    [aStream nextPutAll: ' ... ]'.		    ^self].	    aStream nextPut: $,.	    d car consp		ifTrue: [d car printPrologOn: aStream level: anInteger + 1]		ifFalse: [d car printPrologOn: aStream].	    "d car printPrologOn: aStream level: anInteger + 1."	    count := count + 1.	    d := d cdr].    d isNil	ifTrue: [aStream nextPut: $]]	ifFalse: 	    [aStream nextPut: $|.	    d printPrologOn: aStream.	    aStream nextPut: $]]</body><body package="PrologCore">printPrologOn: aStream level: anInteger     anInteger &gt; PrologDotPairPrintVerticalLevel	ifTrue: 	    [aStream nextPutAll: ' ... '.	    ^self].    aStream nextPutAll: '['.    carPart consp	ifTrue: [carPart printPrologOn: aStream level: anInteger + 1]	ifFalse: [carPart printPrologOn: aStream].    self	printPrologOn: aStream	cdr: cdrPart	level: anInteger</body></methods><methods><class-id>Prolog.PrologList</class-id> <category>private</category><body package="PrologCore">car: carObject cdr: cdrObject     carPart := carObject.    cdrPart := cdrObject</body></methods><methods><class-id>Prolog.PrologList</class-id> <category>accessing</category><body package="PrologCore">car    ^carPart</body><body package="PrologCore">car: carObject     carPart := carObject</body><body package="PrologCore">cdr    ^cdrPart</body><body package="PrologCore">cdr: cdrObject     cdrPart := cdrObject</body><body package="PrologCore">nth: anInteger     | count list |    anInteger &lt;= 0 ifTrue: [^self].    count := 1.    list := self.    [list consp]	whileTrue: 	    [count &gt;= anInteger ifTrue: [^list car].	    count := count + 1.	    list := list cdr].    ^nil</body></methods><methods><class-id>Prolog.PrologList</class-id> <category>enumerating</category><body package="PrologCore">do: aBlock    | list |    list := self.    [list consp] whileTrue: [	aBlock value: list car.	list := list cdr]</body></methods><methods><class-id>Prolog.PrologList</class-id> <category>converting</category><body package="PrologCore">asPrologList    | list new tail |    new := self car cons: nil.    tail := new.    list := self cdr.    [list consp]	whileTrue: 	    [tail cdr: (list car cons: nil).	    tail := tail cdr.	    list := list cdr].    tail cdr: list.    ^new</body></methods><methods><class-id>Prolog.PrologList class</class-id> <category>class initialization</category><body package="PrologCore">initialize    "PrologList initialize"    PrologDotPairPrintVerticalLevel := 10.    PrologDotPairPrintHorizontalLevel := 100</body></methods><methods><class-id>Prolog.PrologList class</class-id> <category>instance creation</category><body package="PrologCore">car: carObject cdr: cdrObject     ^super new car: carObject cdr: cdrObject</body><body package="PrologCore">list: anArray    | size list |    size := anArray size.    list := nil.    size	to: 1	by: -1	do: [:i | list := self car: (anArray at: i) cdr: list].    ^list</body></methods><methods><class-id>Prolog.PrologClause</class-id> <category>printing</category><body package="PrologCore">prettyPrintPrologOn: aStream     | head body |    head := self head.    body := self body.    head printPrologOn: aStream.    body ~~ nil	ifTrue: 	    [aStream nextPutAll: ' :- '.	    body prettyPrintPrologOn: aStream].    aStream nextPut: $.</body><body package="PrologCore">prettyPrintPrologString    | aStream |    aStream := WriteStream on: (String new: 20).    self prettyPrintPrologOn: aStream.    ^aStream contents</body><body package="PrologCore">printPrologOn: aStream     | head body |    head := self head.    body := self body.    aStream nextPut: $(.    head printPrologOn: aStream.    body == nil	ifFalse: 	    [aStream nextPutAll: ', '.	    body printPrologOn: aStream].    aStream nextPut: $)</body><body package="PrologCore">printPrologOn: aStream level: anInteger    self printPrologOn: aStream</body></methods><methods><class-id>Prolog.PrologClause</class-id> <category>accessing</category><body package="PrologCore">body    ^cdrPart</body><body package="PrologCore">body: aPrologBody     cdrPart := aPrologBody</body><body package="PrologCore">head    ^carPart</body><body package="PrologCore">head: aPrologStructure     carPart := aPrologStructure</body></methods><methods><class-id>Prolog.PrologClause</class-id> <category>polymorphism</category><body package="PrologCore">isResolveClause    ^false</body></methods><methods><class-id>Prolog.PrologClause</class-id> <category>private</category><body package="PrologCore">head: aPrologStructure body: aPrologBody     self head: aPrologStructure.    self body: aPrologBody</body></methods><methods><class-id>Prolog.PrologClause class</class-id> <category>instance creation</category><body package="PrologCore">head: aPrologStructure body: aPrologBody     ^super new head: aPrologStructure body: aPrologBody</body></methods><methods><class-id>Prolog.PrologString</class-id> <category>comparing</category><body package="PrologCore">&lt; aPrologString     ^self string &lt; aPrologString string</body><body package="PrologCore">&lt;= aPrologString     ^self string &lt;= aPrologString string</body><body package="PrologCore">&gt; aPrologString     ^self string &gt; aPrologString string</body><body package="PrologCore">&gt;= aPrologString     ^self string &gt;= aPrologString string</body><body package="PrologCore">hash    ^self asString hash</body></methods><methods><class-id>Prolog.PrologString</class-id> <category>converting</category><body package="PrologCore">asString    ^self string</body></methods><methods><class-id>Prolog.PrologString</class-id> <category>accessing</category><body package="PrologCore">at: index    ^string at: index</body><body package="PrologCore">at: index put: char    ^string at: index put: char</body><body package="PrologCore">size    ^string size</body><body package="PrologCore">string    ^string</body><body package="PrologCore">string: aString    string := aString</body></methods><methods><class-id>Prolog.PrologString</class-id> <category>printing</category><body package="PrologCore">printOn: aStream     aStream nextPutAll: self class printString.    aStream nextPutAll: '('.    aStream nextPutAll: self asString.    aStream nextPutAll: ')'</body><body package="PrologCore">printPrologOn: aStream     | i length x |    aStream nextPut: $".    i := 0.    length := string size.    [(i := i + 1) &lt;= length]	whileTrue: 	    [aStream nextPut: (x := string at: i).	    x == $" ifTrue: [aStream nextPut: x]].    aStream nextPut: $"</body><body package="PrologCore">printPrologOn: aStream level: anInteger     self printPrologOn: aStream</body></methods><methods><class-id>Prolog.PrologString</class-id> <category>enumerating</category><body package="PrologCore">do: aBlock    ^self asString do: aBlock</body></methods><methods><class-id>Prolog.PrologString</class-id> <category>testing</category><body package="PrologCore">= anObject     anObject class = self class ifFalse: [^false].    ^self string = anObject string</body></methods><methods><class-id>Prolog.PrologString class</class-id> <category>instance creation</category><body package="PrologCore">fromString: aString     ^super new string: aString</body><body package="PrologCore">readFrom: aStream     | buffer char string |    buffer := WriteStream on: (String new: 20).    char := aStream next.    char = $" ifTrue: [	[char := aStream peek.	char ~~ nil]	    whileTrue: 		[char = $"		    ifTrue: 			[aStream next.			char := aStream peek.			char = $" ifFalse: [^self fromString: buffer contents]].		buffer nextPut: aStream next]].    string := aStream upToEnd.    string size &gt; 100 ifTrue: [string := string copyFrom: 1 to: 100].    self error: 'Syntax error near $" unmatched $"\' withCRs , (string = ''		    ifTrue: ['-- end of file --']		    ifFalse: ['--&gt; ' , string])</body></methods><methods><class-id>Prolog.PrologString class</class-id> <category>accessing</category><body package="PrologCore">charMap: map    charMap := map</body><body package="PrologCore">charMapAt: char    | index |    index := char asInteger.    ^index = 0	ifTrue: [false]	ifFalse: [charMap at: index]</body></methods><methods><class-id>Prolog.PrologVariable</class-id> <category>printing</category><body package="PrologCore">printPrologOn: aStream     (self asString at: 1)	= $~	ifTrue: [aStream nextPut: $~]	ifFalse: [aStream nextPutAll: self asString]</body><body package="PrologCore">printPrologOn: aStream level: anInteger    self printPrologOn: aStream</body></methods><methods><class-id>Prolog.PrologVariable</class-id> <category>testing</category><body package="PrologCore">isPrologVariable    ^true</body></methods><methods><class-id>Prolog.PrologVariable class</class-id> <category>private</category><body package="PrologCore">countUp    PrologVariableCounter := PrologVariableCounter + 1</body><body package="PrologCore">setZero    PrologVariableCounter := 0</body></methods><methods><class-id>Prolog.PrologVariable class</class-id> <category>class initialization</category><body package="PrologCore">initialize    "PrologVariable initialize"    | newMap |    newMap := Array new: 256 withAll: false.    newMap atAll: ($0 asInteger to: $9 asInteger)	put: true.    newMap atAll: ($A asInteger to: $Z asInteger)	put: true.    newMap atAll: ($a asInteger to: $z asInteger)	put: true.    newMap at: $~ asInteger put: true.    self charMap: newMap.    self setZero.    PrologVariableTable := Dictionary new</body></methods><methods><class-id>Prolog.PrologVariable class</class-id> <category>instance creation</category><body package="PrologCore">install: aString     | variable key |    variable := PrologVariableTable at: aString ifAbsent: [nil].    variable == nil	ifTrue: 	    [key := aString.	    variable := self fromString: aString.	    PrologVariableTable at: key put: variable].    ^variable</body><body package="PrologCore">readFrom: aStream     | buffer char |    buffer := WriteStream on: (String new: 20).    char := aStream peek.    (char ~~ nil and: [char = $~])	ifTrue: 	    [aStream next.	    self countUp.	    ^self install: '~' , PrologVariableCounter printString].    [char ~~ nil and: [ self charMapAt: char]]	whileTrue: 	    [buffer nextPut: aStream next.	    char := aStream peek].    ^self install: buffer contents</body></methods><methods><class-id>Prolog.PrologDefinition</class-id> <category>private</category><body package="PrologCore">clause: aPrologClause next: link     carPart := aPrologClause.    cdrPart := link</body><body package="PrologCore">fromList: aPrologDotPair     ^self fromReverseList: aPrologDotPair reverse</body><body package="PrologCore">fromReverseList: aPrologDotPair     | list definition |    list := aPrologDotPair.    definition := nil.    [list consp]	whileTrue: 	    [definition := self class clause: list car next: definition.	    list := list cdr].    ^definition</body></methods><methods><class-id>Prolog.PrologDefinition class</class-id> <category>instance creation</category><body package="PrologCore">clause: aPrologClause next: link     ^super new clause: aPrologClause next: link</body><body package="PrologCore">fromList: aPrologDotPair     aPrologDotPair consp ifFalse: [^aPrologDotPair].    ^super new fromList: aPrologDotPair</body><body package="PrologCore">fromReverseList: aPrologDotPair     aPrologDotPair consp ifFalse: [^aPrologDotPair].    ^super new fromReverseList: aPrologDotPair</body></methods><methods><class-id>Prolog.PrologInterpreter</class-id> <category>binding and unbinding</category><body package="PrologCore">bind: x env: xEnv and: y env: yEnv     | list |    list := (self fetchValue: y env: yEnv) cons: valueEnv.    list := (x cons: list) cons: xEnv cdr.     xEnv cdr: list.     unbindList := xEnv cons: unbindList</body><body package="PrologCore">binding: x env: xEnv     | assocList |    assocList := xEnv cdr.    assocList == nil ifTrue: [^nil].    ^assocList assoc: x</body><body package="PrologCore">fetchValue: x env: xEnv     | xx xxEnv assoc |    xx := x.    xxEnv := xEnv.    [true]	whileTrue: 	    [valueEnv := xxEnv.	    xx isPrologVariable		ifTrue: 		    [assoc := self binding: xx env: xxEnv.		    assoc == nil ifTrue: [^xx].		    assoc := assoc cdr.		    xx := assoc car.		    xxEnv := assoc cdr]		ifFalse: [^xx]]</body><body package="PrologCore">noValue: x env: xEnv     | assoc |    x isPrologVariable	ifTrue: 	    [assoc := self binding: x env: xEnv.	    assoc == nil ifTrue: [^true].	    assoc := assoc cdr.	    ^self noValue: assoc car env: assoc cdr].    ^false</body><body package="PrologCore">nullEnv    envCounter := envCounter + 1.    ^envCounter cons: nil</body><body package="PrologCore">unbindFrom: start to: end     | list env assocList |    list := start.    [list ~~ end]	whileTrue: 	    [env := list car.	    assocList := env cdr.	    assocList car cdr cdr: nil.	    env cdr: assocList cdr.	    list := list cdr]</body></methods><methods><class-id>Prolog.PrologInterpreter</class-id> <category>outputting</category><body package="PrologCore">outputAnswer: dict     | anArray string assoc associations |    associations := OrderedCollection new.    dict associationsDo: [:association | associations add: association].    anArray := associations asSortedCollection.    1 to: anArray size do: [:i | 	assoc := anArray at: i.	i = 1	    ifTrue: [string := '']	    ifFalse: [string := ',\' withCRs].	string := string , assoc key.	string := string , ' = '.	string := string , assoc value printPrologString.	string := string , ' '.	textCollector show: string]</body><body package="PrologCore">outputTime: msec     | goal string |    verbose	ifTrue: 	    [goal := envCounter - 1.	    string := '&lt;'.	    string := string , msec printString , ' milliseconds, '.	    string := string , goal printString , ' goals'.	    string := string , '&gt;\' withCRs.	    textCollector show: string asText]</body><body package="PrologCore">outputVariables: aDictionary    | bool |    self outputAnswer: aDictionary.    bool := Dialog confirm: 'All right ?'.    bool	ifTrue: [textCollector cr]	ifFalse: [textCollector show: ';\' withCRs].    ^bool</body></methods><methods><class-id>Prolog.PrologInterpreter</class-id> <category>system support</category><body package="PrologCore">clauseSet: aPrologClause     | horn functor def |    horn := aPrologClause.    horn consp ifFalse: [horn := PrologStructure functor: horn terms: nil].    horn car consp ifFalse: [horn := PrologClause head: horn body: nil].    horn := PrologClause head: horn car body: (PrologBody fromList: horn cdr).    functor := horn car car.    def := userPredicates at: functor ifAbsent: [^false].    definitionStack := def cons: definitionStack.    ^true</body><body package="PrologCore">consult: readStream action: aBlock    | condition parser node hornClause program functor stream result |    condition := self getCondition.    parser := PrologParser new.    result := true.    [node := parser parse: readStream.    node == #eof]	whileFalse: 	    [hornClause := node.	    node isResolveClause		ifTrue: 		    [stream := WriteStream on: (String new: 20).		    hornClause printPrologOn: stream.		    textCollector show: stream contents.		    textCollector cr.		    result := self resolve: hornClause action: aBlock]		ifFalse: 		    [functor := hornClause car car.		    program := tracePredicates at: functor ifAbsent: [userPredicates at: functor ifAbsent: []].		    program == nil			ifTrue: 			    [program := PrologDefinition fromList: (hornClause cons: nil).			    userPredicates at: functor put: program]			ifFalse: [program nconc: (hornClause cons: nil)]]].    self putCondition: condition.    ^result</body><body package="PrologCore">reconsult: readStream action: aBlock    | condition newPredicates parser node hornClause program functor stream result |    condition := self getCondition.    newPredicates := Dictionary new.    parser := PrologParser new.    result := true.    [node := parser parse: readStream.    node == #eof]	whileFalse: 	    [hornClause := node.	    node isResolveClause		ifTrue: 		    [stream := WriteStream on: (String new: 20).		    hornClause printPrologOn: stream.		    textCollector show: stream contents.		    textCollector cr.		    result := self resolve: hornClause action: aBlock]		ifFalse: 		    [functor := hornClause car car.		    program := newPredicates at: functor ifAbsent: [].		    program == nil			ifTrue: 			    [program := PrologDefinition fromList: (hornClause cons: nil).			    newPredicates at: functor put: program]			ifFalse: [program nconc: (hornClause cons: nil)].		    userPredicates at: functor put: program]].    newPredicates keys	do: [:eachPredicate |	    userPredicates at: eachPredicate put: (newPredicates at: eachPredicate).	    tracePredicates removeKey: eachPredicate ifAbsent: []].    self putCondition: condition.    ^result</body><body package="PrologCore">saveFileName	^Dialog		requestFileName: 'Save Prolog definitions'		default: '*.pl'		version: #new</body><body package="PrologCore">saveOn: fileName	| aFileStream def |	fileName = '' ifTrue: [^false].		[aFileStream := fileName asFilename writeStream.	(self associations: userPredicates) asSortedCollection do: 			[:assoc |			def := assoc value.			[def consp] whileTrue: 					[aFileStream nextPutAll: def car prettyPrintPrologString , '\' withCRs.					def := def cdr]]]			ensure: [aFileStream close]</body><body package="PrologCore">saveOn: fileName predicateName: aPrologSymbol	| aFileStream def |	fileName = '' ifTrue: [^false].		[aFileStream := fileName asString writeStream.	def := userPredicates at: aPrologSymbol ifAbsent: [].	def == nil		ifFalse: 			[[def consp] whileTrue: 					[aFileStream nextPutAll: def car prettyPrintPrologString , '\' withCRs.					def := def cdr]]]			ensure: [aFileStream close]</body><body package="PrologCore">systemConsult: readStream     | condition parser node hornClause program functor |    condition := self getCondition.    parser := PrologParser new.    [node := parser parse: readStream.    node == #eof]	whileFalse: 	    [hornClause := node.	    node isResolveClause		ifTrue: [self resolve: hornClause]		ifFalse: 		    [functor := hornClause car car.		    program := systemPredicates at: functor ifAbsent: [].		    program == nil			ifTrue: 			    [program := PrologDefinition fromList: (hornClause cons: nil).			    systemPredicates at: functor put: program]			ifFalse: [program nconc: (hornClause cons: nil)]]].    self putCondition: condition.    ^true</body><body package="PrologCore">systemReconsult: readStream     | condition newPredicates parser node hornClause program functor |    condition := self getCondition.    newPredicates := Dictionary new.    parser := PrologParser new.    [node := parser parse: readStream.    node == #eof]	whileFalse: 	    [hornClause := node.	    node isResolveClause		ifTrue: [self resolve: hornClause]		ifFalse: 		    [functor := hornClause car car.		    program := newPredicates at: functor ifAbsent: [].		    program == nil			ifTrue: 			    [program := PrologDefinition fromList: (hornClause cons: nil).			    newPredicates at: functor put: program]			ifFalse: [program nconc: (hornClause cons: nil)].		    systemPredicates at: functor put: program]].    newPredicates keys do: [:eachPredicate | systemPredicates at: eachPredicate put: (newPredicates at: eachPredicate)].    self putCondition: condition.    ^true</body><body package="PrologCore">trace: para head: head arguments: terms     | headString numberString structure arguString |    headString := (self expression: head env: clauseEnv) printPrologString.    para = 0	ifTrue: 	    [traceCounter := traceCounter + 1.	    numberString := String new: traceCounter withAll: $|.	    structure := PrologStructure functor: head car terms: terms.	    arguString := (self expression: structure env: clauseEnv) printPrologString.	    headString := headString , ' ~ ' , arguString.	    textCollector show: numberString , ' CALL : ' , headString , '\' withCRs.	    ^self].    para = 1	ifTrue: 	    [traceCounter := traceCounter + 1.	    numberString := String new: traceCounter withAll: $|.	    structure := PrologStructure functor: head car terms: terms.	    arguString := (self expression: structure env: clauseEnv) printPrologString.	    headString := headString , ' ~ ' , arguString.	    textCollector show: numberString , ' REDO : ' , headString , '\' withCRs.	    ^self].    para = 2	ifTrue: 	    [numberString := String new: traceCounter withAll: $|.	    textCollector show: numberString , ' FAIL : ' , headString , '\' withCRs.	    traceCounter := traceCounter - 1.	    ^self].    para = 3	ifTrue: 	    [numberString := String new: traceCounter withAll: $|.	    textCollector show: numberString , ' EXIT : ' , headString , '\' withCRs.	    ^self]</body><body package="PrologCore">traceCallClause: head    ^self traceClause: head flag: 0</body><body package="PrologCore">traceClause: head flag: anInteger     | arguVar headStruct failStruct traceStruct |    arguVar := PrologVariable install: 'Arguments'.    headStruct := PrologStructure functor: head car terms: arguVar.    failStruct := PrologStructure functor: (PrologSymbol install: 'fail')		terms: nil.    traceStruct := arguVar cons: nil.    traceStruct := head cons: traceStruct.    traceStruct := anInteger cons: traceStruct.    traceStruct := traceStruct cons: nil.    traceStruct := (PrologSymbol install: 'trace:head:arguments:')		cons: traceStruct.    traceStruct := (PrologSymbol install: 'self')		cons: traceStruct.    traceStruct := PrologTerms fromList: traceStruct.    traceStruct := PrologStructure functor: (PrologSymbol install: 'send')		terms: traceStruct.    anInteger = 3 ifTrue: [^PrologClause head: headStruct body: (PrologBody fromList: (traceStruct cons: nil))].    ^PrologClause head: headStruct body: (PrologBody fromList: (traceStruct cons: (failStruct cons: nil)))</body><body package="PrologCore">traceExitClause: exitClause    | traceExitClause reverseClone|     traceExitClause := self traceExitClauseAux: exitClause car.    traceExitClause := traceExitClause cdr.    reverseClone := exitClause reverse.    [reverseClone consp]	whileTrue:	    [traceExitClause := reverseClone car cons: traceExitClause.	    reverseClone := reverseClone cdr].    ^PrologClause head: traceExitClause car body: (PrologBody fromList: traceExitClause cdr)</body><body package="PrologCore">traceExitClauseAux: head    ^self traceClause: head flag: 3</body><body package="PrologCore">traceFailClause: head    ^self traceClause: head flag: 2</body><body package="PrologCore">traceRedoClause: head    ^self traceClause: head flag: 1</body></methods><methods><class-id>Prolog.PrologInterpreter</class-id> <category>kernel predicates</category><body package="PrologCore">builtInCut    backTrack := cutBack car.    clause := clause cdr.    status := #loop</body><body package="PrologCore">builtInFail    status := #back</body><body package="PrologCore">builtInPredicate: functor     functor isPrologCut ifTrue: [^self builtInCut].    functor isPrologTrue ifTrue: [^self builtInTrue].    functor isPrologFail ifTrue: [^self builtInFail].    functor isPrologSend ifTrue: [^self builtInSend].    functor isPrologVar ifTrue: [^self builtInVar].    self error: 'Unexpected built-in predicate'</body><body package="PrologCore">builtInSend    | list receiverSymbol selectorSymbol argumentList unifyTerm result |    list := self expression: clause car cdr env: clauseEnv.    receiverSymbol := list car.    list := list cdr.    selectorSymbol := list car.    list := list cdr.    argumentList := list car.    list := list cdr.    list == nil	ifTrue: [unifyTerm := nil]	ifFalse: [list cdr == nil		ifTrue: [unifyTerm := clause car cdr nth: 4]		ifFalse: 		    [status := #back.		    ^self]].    result := self		receiver: receiverSymbol		selector: selectorSymbol		arguments: argumentList.    result = PrologSymbol cut	ifTrue: 	    [self builtInCut.	    status := #back.	    ^self].    unifyTerm isNil	ifTrue: 	    [result = false ifFalse: [result := true].	    result		ifTrue: 		    [clause := clause cdr.		    status := #loop.		    ^self]		ifFalse: 		    [status := #back.		    ^self]]	ifFalse: [(self		unify: unifyTerm		env: clauseEnv		and: result		env: self nullEnv)		ifTrue: 		    [clause := clause cdr.		    status := #loop.		    ^self]		ifFalse: 		    [status := #back.		    ^self]].    ^self</body><body package="PrologCore">builtInTrue    clause := clause cdr.    status := #loop</body><body package="PrologCore">builtInVar    | var |    var := clause car cdr car.    (self noValue: var env: clauseEnv)	ifTrue: 	    [clause := clause cdr.	    status := #loop]	ifFalse: [status := #back]</body><body package="PrologCore">call: aPrologStructure     | structure functor |    aPrologStructure cdr == nil	ifTrue: 	    [self callVariable: aPrologStructure car.	    ^self].    structure := self expression: aPrologStructure env: clauseEnv.    (self	unify: aPrologStructure	env: clauseEnv	and: structure	env: clauseEnv)	ifFalse: [self error: 'Unexpected unify structure'].    functor := structure car.    functor isPrologVariable	ifTrue: 	    [status := #back.	    ^self].    clause := clause cdr.    clause := structure cons: clause.    status := #loop</body><body package="PrologCore">callVariable: aPrologVariable     | horn functor |    horn := self expression: aPrologVariable env: clauseEnv.    (self	unify: aPrologVariable	env: clauseEnv	and: horn	env: clauseEnv)	ifFalse: [self error: 'Unexpected unify horn clause'].    horn consp ifFalse: [horn := PrologStructure functor: horn terms: nil].    horn car consp ifFalse: [horn := PrologClause head: horn body: nil].    horn := PrologClause head: horn car body: (PrologBody fromList: horn cdr).    functor := horn car car.    functor isPrologVariable	ifTrue: 	    [status := #back.	    ^self].    clause := clause cdr.    horn := horn reverse.    [horn consp]	whileTrue: 	    [clause := horn car cons: clause.	    horn := horn cdr].    status := #loop</body><body package="PrologCore">receiver: receiverSymbol selector: selectorSymbol arguments: argumentList	| receiver size selector arguments list result index |	((receiverSymbol isKindOf: PrologSymbol)		and: [receiverSymbol isPrologSelf])			ifTrue: [receiver := self]			ifFalse: [receiver := receiverSymbol].	(receiver isKindOf: PrologObject) ifTrue: [receiver := receiver object].	size := selectorSymbol size.	selector := String new: size.	1 to: size do: [:i | selector at: i put: (selectorSymbol at: i)].	selector := selector asSymbol.	list := argumentList.	list == nil		ifTrue: 			[arguments := Array new.			result := receiver perform: selector]		ifFalse: 			[size := list length.			arguments := Array new: size.			1 to: size				do: 					[:i |					arguments at: i						put: ((list car isKindOf: PrologObject)								ifTrue: [list car object]								ifFalse: [list car]).					list := list cdr].			result := receiver perform: selector withArguments: arguments].	((result = true or: [result = false]) or: [result isPrologEntity])		ifTrue: [result := result yourself]		ifFalse: 			[list := PrologList car: receiverSymbol cdr: argumentList.			index := (Array with: receiver) , arguments						findFirst: [:each | each = result].			index = 0				ifTrue: [result := PrologObject source: result printString object: result]				ifFalse: [result := list nth: index]].	^result</body></methods><methods><class-id>Prolog.PrologInterpreter</class-id> <category>public accessing</category><body package="PrologCore">refute: stringOrStream    ^self refute: stringOrStream action: [:answer | ^answer]</body><body package="PrologCore">refute: stringOrStream action: aBlock     | stream |    (stringOrStream isKindOf: Stream)	ifTrue: [stream := ReadStream on: stringOrStream contents]	ifFalse: [stream := ReadStream on: stringOrStream].    ^self consult: stream action: aBlock</body></methods><methods><class-id>Prolog.PrologInterpreter</class-id> <category>system predicates</category><body package="PrologCore">asserta: aPrologClause	| horn def functor |	horn := aPrologClause.	horn consp ifFalse: [horn := PrologStructure functor: horn terms: nil].	horn car consp ifFalse: [horn := PrologClause head: horn body: nil].	horn := PrologClause head: horn car body: (PrologBody fromList: horn cdr).	functor := horn car car.	def := userPredicates at: functor ifAbsent: [nil].	def == nil		ifTrue: [def := PrologDefinition fromList: (horn cons: nil)]		ifFalse: [def := PrologDefinition fromList: (horn cons: def)].	userPredicates at: functor put: def.	^true</body><body package="PrologCore">assertz: aPrologClause     | horn def functor |    horn := aPrologClause.    horn consp ifFalse: [horn := PrologStructure functor: horn terms: nil].    horn car consp ifFalse: [horn := PrologClause head: horn body: nil].    horn := PrologClause head: horn car body: (PrologBody fromList: horn cdr).    functor := horn car car.    def := userPredicates at: functor ifAbsent: [nil].    def == nil	ifTrue: 	    [def := PrologDefinition fromList: (horn cons: nil).	    userPredicates at: functor put: def]	ifFalse: [def nconc: (PrologDefinition fromList: (horn cons: nil))].    ^true</body><body package="PrologCore">clause: aPrologClause     | count horn def result |    count := 0.    horn := aPrologClause.    horn consp	ifFalse: 	    [horn := PrologStructure functor: horn terms: nil.	    count := count + 1].    horn car consp	ifFalse: 	    [horn := PrologClause head: horn body: nil.	    count := count + 1].    horn := PrologClause head: horn car body: (PrologBody fromList: horn cdr).    def := definitionStack car.    [def consp]	whileTrue: [(self		unify: horn		env: self nullEnv		and: def car		env: self nullEnv)		ifTrue: 		    [result := def car.		    count timesRepeat: [result := result car].		    def := def cdr.		    definitionStack car: def.		    ^result]		ifFalse: 		    [def := def cdr.		    definitionStack car: def]].    definitionStack := definitionStack cdr.    ^PrologSymbol cut</body><body package="PrologCore">clear    textCollector clear.    ^true</body><body package="PrologCore">consultFile: fileSymbol	| aFileStream |	(fileSymbol respondsTo: #asString) ifFalse: [^false].	fileSymbol asString asFilename exists		ifTrue: 			[textCollector show: '&lt;consult from ' , fileSymbol asString , '&gt;\' withCRs.			aFileStream := fileSymbol asString asFilename readStream.			self consult: aFileStream action: nil.			aFileStream close.			^true]		ifFalse: [^false]</body><body package="PrologCore">dotp: x     ^x consp</body><body package="PrologCore">double: x    ^x isKindOf: Float</body><body package="PrologCore">float: x    ^x isKindOf: Float</body><body package="PrologCore">fraction: x    ^x isKindOf: Fraction</body><body package="PrologCore">functorArityOf: aPrologStructure     aPrologStructure isNil ifTrue: [^nil cons: 0].    (self number: aPrologStructure)	ifTrue: [^aPrologStructure cons: 0].    (aPrologStructure respondsTo: #functor)	ifFalse: [^nil].    ^aPrologStructure functor cons: aPrologStructure arity</body><body package="PrologCore">gc    ObjectMemory garbageCollect.    self textCollector cr; show: 'garbage collecting... ';cr.    ^true</body><body package="PrologCore">integer: x    ^x isKindOf: Integer</body><body package="PrologCore">length: aPrologDotPair     aPrologDotPair consp ifFalse: [^0].    ^aPrologDotPair length</body><body package="PrologCore">list: x     x == nil ifTrue: [^true].    ^self dotp: x</body><body package="PrologCore">listPrint: aPrologDotPair     | list |    aPrologDotPair consp ifFalse: [^false].    list := aPrologDotPair.    [list consp]	whileTrue: 	    [textCollector show: list car printPrologString , ' '.	    list := list cdr].    ^true</body><body package="PrologCore">nl    textCollector cr.    ^true</body><body package="PrologCore">nospy: aPrologSymbol     | def |    def := tracePredicates at: aPrologSymbol ifAbsent: [nil].    def == nil ifTrue: [^false].    userPredicates at: aPrologSymbol put: def.    tracePredicates removeKey: aPrologSymbol.    ^true</body><body package="PrologCore">notrace    userPredicates associationsDo: [:assoc | self nospy: assoc key].    ^true</body><body package="PrologCore">number: x    ^x isKindOf: Number</body><body package="PrologCore">reconsultFile: fileSymbol	| aFileStream |	(fileSymbol respondsTo: #asString) ifFalse: [^false].	fileSymbol asString asFilename exists		ifTrue: 			[textCollector				show: '&lt;reconsult from ' , fileSymbol asString , '&gt;\' withCRs.			aFileStream := fileSymbol asString asFilename readStream.			self reconsult: aFileStream action: nil.			aFileStream close.			^true]		ifFalse: [^false]</body><body package="PrologCore">remove    userPredicates keys do: 	[:aPrologSymbol | 	userPredicates removeKey: aPrologSymbol ifAbsent: [].	tracePredicates removeKey: aPrologSymbol ifAbsent: []].    ^true</body><body package="PrologCore">remove: aPrologSymbol    userPredicates removeKey: aPrologSymbol ifAbsent: [^false].    tracePredicates removeKey: aPrologSymbol ifAbsent: [].    ^true</body><body package="PrologCore">retract: aPrologClause     | count horn def functor prev result |    count := 0.    horn := aPrologClause.    horn consp	ifFalse: 	    [horn := PrologStructure functor: horn terms: nil.	    count := count + 1].    horn car consp	ifFalse: 	    [horn := PrologClause head: horn body: nil.	    count := count + 1].    horn := PrologClause head: horn car body: (PrologBody fromList: horn cdr).    functor := horn car car.    prev := def := userPredicates at: functor ifAbsent: [^PrologSymbol cut].    [def consp]	whileTrue: [(self		unify: horn		env: self nullEnv		and: def car		env: self nullEnv)		ifTrue: 		    [result := def car.		    count timesRepeat: [result := result car].		    prev == def			ifTrue: 			    [def cdr isNil				ifTrue: [userPredicates removeKey: functor ifAbsent: [nil]]				ifFalse: [userPredicates at: functor put: def cdr].			    ^result]			ifFalse: 			    [prev cdr: def cdr.			    ^result]]		ifFalse: 		    [prev := def.		    def := def cdr]].    ^PrologSymbol cut</body><body package="PrologCore">saving    self saveOn: self saveFileName.    ^true</body><body package="PrologCore">saving: aPrologSymbol     | def |    def := tracePredicates at: aPrologSymbol ifAbsent: [userPredicates at: aPrologSymbol ifAbsent: []].    def == nil ifTrue: [^false].    self saveOn: self saveFileName.    ^true</body><body package="PrologCore">spy: aPrologSymbol     | def reverseClone tracedef |    def := userPredicates at: aPrologSymbol ifAbsent: [nil].    def == nil ifTrue: [^false].    (tracePredicates at: aPrologSymbol ifAbsent: [nil]) isNil ifFalse: [^true].    tracePredicates at: aPrologSymbol put: def.    reverseClone := nil.    [def consp]	whileTrue: 	    [reverseClone := def car cons: reverseClone.	    def := def cdr].    tracedef := nil.    [reverseClone consp]	whileTrue: 	    [tracedef := (self traceFailClause: reverseClone car car)			cons: tracedef.	    tracedef := (self traceExitClause: reverseClone car)			cons: tracedef.	    reverseClone cdr consp		ifTrue: [tracedef := (self traceRedoClause: reverseClone car car)				cons: tracedef]		ifFalse: [tracedef := (self traceCallClause: reverseClone car car)				cons: tracedef].	    reverseClone := reverseClone cdr].    userPredicates at: aPrologSymbol put: (PrologDefinition fromList: tracedef).    ^true</body><body package="PrologCore">strToSym: listOrString     | stream string token s |    listOrString consp	ifTrue: 	    [s := WriteStream on: (String new: 16).	    listOrString do: [:char | s nextPut: (Character value: char)].	    string := s contents]	ifFalse: [string := listOrString string].    stream := ReadStream on: string.    token := (PrologScanner new on: stream) nextToken.    ((self number: token)	and: [stream atEnd])	ifTrue: [^token]	ifFalse: [string = '[]'		ifTrue: [^nil]		ifFalse: [^PrologSymbol install: string]]</body><body package="PrologCore">string: x    ^x class == PrologString</body><body package="PrologCore">symToList: numOrSym     | pstring |    pstring := self symToStr: numOrSym.    ^PrologList list: pstring string asByteArray</body><body package="PrologCore">symToStr: numOrSym     numOrSym isNil ifTrue: [^PrologString fromString: '[]'].    (self number: numOrSym)	ifTrue: [^PrologString fromString: numOrSym printString].    ^PrologString fromString: numOrSym string</body><body package="PrologCore">symbol: x    ^x class == PrologSymbol</body><body package="PrologCore">systemListing    | predicateName |    (self associations: systemPredicates) asSortedCollection	do: 	    [:assoc | 	    predicateName := assoc key.	    ((predicateName respondsTo: #asString)		and: [predicateName string isEmpty not and: [predicateName string first = $~]])		ifFalse: [self systemListing: predicateName]].    ^true</body><body package="PrologCore">systemListing: aPrologSymbol    | def |    def := systemPredicates at: aPrologSymbol ifAbsent: [nil].    def == nil ifTrue: [^false].    [def consp]	    whileTrue: 		[textCollector show: def car prettyPrintPrologString , '\' withCRs.		def := def cdr].    ^true</body><body package="PrologCore">systemPredicates    | collection list |    collection := (self associations: systemPredicates) asSortedCollection.    list := nil.    collection reverseDo: [:each | ((each key respondsTo: #asString)	    and: [each key string isEmpty not and: [each key string first = $~]])	    ifTrue: ['not adding: invisible predicate' yourself]	    ifFalse: [list := each key cons: list]].    ^list</body><body package="PrologCore">tab: aNumber     | spaces |    (aNumber isKindOf: Number)	ifFalse: [^false].    spaces := String new.    aNumber asInteger timesRepeat: [spaces := spaces , ' '].    textCollector show: spaces.    ^true</body><body package="PrologCore">trace    userPredicates associationsDo: [:assoc | self spy: assoc key].    ^true</body><body package="PrologCore">univ: aPrologList     | termv listv termValue termEnv listVal listEnv functor functorEnv terms newterms newStruct car t list |    termv := PrologVariable install: aPrologList car string.    listv := PrologVariable install: aPrologList cdr string.    termValue := self fetchValue: termv env: clauseEnv.    termEnv := valueEnv.    listVal := self fetchValue: listv env: clauseEnv.    listEnv := valueEnv.    termValue isPrologVariable	ifTrue: 	    ["construct a term from fixed length list."	    listVal isPrologVariable ifTrue: [^false].	    listVal consp ifFalse: [^false].	    functor := self fetchValue: listVal car env: listEnv.	    functorEnv := valueEnv.	    terms := self fetchValue: listVal cdr env: listEnv.	    listEnv := valueEnv.	    (self number: functor)		ifTrue: 		    [terms isNil ifFalse: [^false].		    self			bind: termValue			env: termEnv			and: functor			env: listEnv.		    ^true].	    functor consp ifTrue: ["It's a structure or a list"		^false].	    terms isNil		ifTrue: 		    [self			bind: termValue			env: termEnv			and: functor			env: functorEnv.		    ^true].	    terms consp ifFalse: ["Not a list, but an illegal dot pair."		^false].	    newterms := nil.	    [terms isNil]		whileFalse: 		    [car := terms car.		    terms := self fetchValue: terms cdr env: listEnv.		    terms isPrologVariable ifTrue: ["The length of the list has not been fixed yet."			^false].		    t := PrologTerms car: car cdr: nil.		    newterms isNil			ifTrue: [newterms := t]			ifFalse: [newterms := newterms nconc: t]].	    newStruct := PrologStructure functor: functor terms: newterms.	    ^self		unify: termValue		env: termEnv		and: newStruct		env: listEnv]	ifFalse: 	    ["disasemble a term into a list"	    termValue consp		ifTrue: ["It's a list or a structure."		    list := termValue structureList]		ifFalse: ["primitive data like symbol, number, nil, or string."		    list := termValue cons: nil].	    ^self		unify: list		env: termEnv		and: listVal		env: listEnv]</body><body package="PrologCore">userListing    | predicateName |    ((self associations: userPredicates) asSortedCollection)	do: 	    [:assoc | 	    predicateName := assoc key.	    self userListing: predicateName].    ^true</body><body package="PrologCore">userListing: aPrologSymbol     | def |    def := userPredicates at: aPrologSymbol ifAbsent: [nil].    def == nil ifTrue: [^false].    [def consp]	whileTrue: 	    [textCollector show: def car prettyPrintPrologString , '\' withCRs.	    def := def cdr].    ^true</body><body package="PrologCore">userPredicates    | collection list |    collection := (self associations: userPredicates) asSortedCollection.    list := nil.    collection reverseDo: [:each | ((each key respondsTo: #string)	    and: [each key string isEmpty not and: [each key string first = $~]])	    ifTrue: ['not adding: invisible predicate' yourself]	    ifFalse: [list := each key cons: list]].    ^list</body><body package="PrologCore">verbose: aPrologSymbol     aPrologSymbol isPrologTrue	ifTrue: [verbose := true]	ifFalse: [verbose := false].    ^true</body><body package="PrologCore">write: anObject     (anObject respondsTo: #asString)	ifTrue: [textCollector show: anObject asString]	ifFalse: [textCollector show: anObject printPrologString].    ^true</body></methods><methods><class-id>Prolog.PrologInterpreter</class-id> <category>representation</category><body package="PrologCore">collectVariables    | dict |     dict := Dictionary new.    self collectVariables: question to: dict.    ^dict</body><body package="PrologCore">collectVariables: x to: dict    | key value |      (x isPrologVariable and: [(x at: 1) ~= $~])	ifTrue:	    [key := String fromString: x printPrologString.	    (dict at: key ifAbsent: []) ~~ nil		ifTrue: [^self]		ifFalse: 		    [value := self represent: x env: questionEnv.		    dict at: key put: value]].    (x consp)	ifFalse: [^self].    self collectVariables: x car to: dict.    self collectVariables: x cdr to: dict</body><body package="PrologCore">expression: x env: xEnv     | assoc a d |    x isPrologVariable	ifTrue: 	    [assoc := self binding: x env: xEnv.	    assoc == nil ifTrue: [^x].	    assoc := assoc cdr.	    ^self expression: assoc car env: assoc cdr].    (x consp) ifFalse: [^x].    a := self expression: x car env: xEnv.    d := self expression: x cdr env: xEnv.    ^x class car: a cdr: d</body><body package="PrologCore">represent: x env: xEnv     | assoc a d |    x isPrologVariable	ifTrue: 	    [assoc := self binding: x env: xEnv.	    assoc == nil ifTrue: [^self variableRepresent: x env: xEnv].	    assoc := assoc cdr.	    ^self represent: assoc car env: assoc cdr].    (x consp) ifFalse: [^x].    a := self represent: x car env: xEnv.    d := self represent: x cdr env: xEnv.    ^x class car: a cdr: d</body><body package="PrologCore">variableRepresent: x env: xEnv     ^PrologVariable install: x string , xEnv car printString</body></methods><methods><class-id>Prolog.PrologInterpreter</class-id> <category>resolution</category><body package="PrologCore">resolve: goal     ^self resolve: goal action: nil</body><body package="PrologCore">resolve: goal action: actionBlock    question := clause := goal.    actionBlock == nil	ifTrue: [resolveAction := [:dict | self outputVariables: dict]]	ifFalse: [resolveAction := actionBlock].        self resolveInitialize.    self resolveLoop.    ^self resolveTerminate</body><body package="PrologCore">resolveInitialize    status := #loop.    envCounter := 0.    questionEnv := clauseEnv := self nullEnv.    queue := queueEnv := valueEnv := nil.    unbindList := cutBack := backTrack := nil.    definitionStack := nil.    traceCounter := 0</body><body package="PrologCore">resolveLoop    | totalTime time answer |    totalTime := 0.    time := Time millisecondClockValue.    [true]	whileTrue: 	    [status == #loop ifTrue: [self loop].	    status == #next ifTrue: [self next].	    status == #back ifTrue: [self back].	    status == #succ		ifTrue: 		    [time := Time millisecondClockValue - time.		    self outputTime: (totalTime := totalTime + time).		    answer := self collectVariables.		    answer isEmpty ifTrue: [^true].		    (resolveAction value: answer)			ifTrue: [^true]			ifFalse: 			    [status := #back.			    time := Time millisecondClockValue]].	    status == #fail		ifTrue: 		    [time := Time millisecondClockValue - time.		    self outputTime: (totalTime := totalTime + time).		    ^false]]</body><body package="PrologCore">resolveTerminate    self deallocateEnv: questionEnv.    status == #succ	ifTrue: 	    [textCollector show: 'yes'.	    textCollector cr.	    ^true].    status == #fail	ifTrue: 	    [textCollector show: 'no'.	    textCollector cr.	    ^false].    self error: 'Unexpected status'</body></methods><methods><class-id>Prolog.PrologInterpreter</class-id> <category>private</category><body package="PrologCore">associations: aCollection    "by nishis, 1998/04/12 07:34"    | anOrderedCollection |    anOrderedCollection := OrderedCollection new: aCollection size.    aCollection associationsDo: [:association | anOrderedCollection add: association].    ^ anOrderedCollection</body><body package="PrologCore">deallocateEnv: env    | assocList assoc nextEnv |      assocList := env cdr.    [assocList consp]	whileTrue: 	    [assoc := assocList car.	    nextEnv := assoc cdr cdr.	    assoc cdr cdr: nil.	    nextEnv consp ifTrue: [self deallocateEnv: nextEnv].	    assocList := assocList cdr]</body><body package="PrologCore">getCondition    | condition |    condition := Array new: 14.    condition at: 1 put: status.    condition at: 2 put: definition.    condition at: 3 put: question.    condition at: 4 put: questionEnv.    condition at: 5 put: clause.    condition at: 6 put: clauseEnv.    condition at: 7 put: queue.    condition at: 8 put: queueEnv.    condition at: 9 put: valueEnv.    condition at: 10 put: unbindList.    condition at: 11 put: cutBack.    condition at: 12 put: backTrack.    condition at: 13 put: resolveAction.    condition at: 14 put: definitionStack.    ^condition</body><body package="PrologCore">makeSystemPredicates	self systemPredicatesNo0.	self systemPredicatesNo1.	self systemPredicatesNo2.	self systemPredicatesNo3.	self systemPredicatesNo4.	self systemPredicatesNo5.	self systemPredicatesNo6.	self systemPredicatesNo7.	self systemPredicatesNo8.	self systemPredicatesNo9</body><body package="PrologCore">putCondition: condition     status := condition at: 1.    definition := condition at: 2.    question := condition at: 3.    questionEnv := condition at: 4.    clause := condition at: 5.    clauseEnv := condition at: 6.    queue := condition at: 7.    queueEnv := condition at: 8.    valueEnv := condition at: 9.    unbindList := condition at: 10.    cutBack := condition at: 11.    backTrack := condition at: 12.    resolveAction := condition at: 13.    definitionStack := condition at: 14</body><body package="PrologCore">systemPredicatesNo0        self systemReconsult: (ReadStream on: '	! :- builtin.	true :- builtin.	fail :- builtin.	var(X) :- builtin.	send(X,Y,Z) :- builtin.	send(X,Y,Z,A) :- builtin.    ')</body><body package="PrologCore">systemPredicatesNo1        self systemReconsult: (ReadStream on: '	repeat.	repeat :- repeat.	nonvar(X) :- var(X), !, fail.	nonvar(X).	integer(X) :- send(self,integer:,[X]).	float(X) :- send(self,float:,[X]).	double(X) :- send(self,double:,[X]).	fraction(X) :- send(self,fraction:,[X]).	number(X) :- send(self,number:,[X]).	symbol(X) :- send(self,symbol:,[X]).	string(X) :- send(self,string:,[X]).	list(X) :- send(self,list:,[X]).	dotp(X) :- send(self,dotp:,[X]).	atom(X) :- symbol(X).	atom(X) :- nonvar(X), =(X,[]).	atom(X) :- string(X).	atomic(X) :- atom(X).	atomic(X) :- number(X).	structure(X) :- nonvar(X), not(atomic(X)).    ')</body><body package="PrologCore">systemPredicatesNo2        self systemReconsult: (ReadStream on: '	==(X,Y) :- send(X,=,[Y]).	\==(X,Y) :- ==(X,Y), !, fail.	\==(X,Y).	=(X,X).	\=(X,Y) :- =(X,Y), !, fail.	\=(X,Y).	&gt;(X,Y) :- send(X,&gt;,[Y]).	&gt;=(X,Y) :- send(X,&gt;=,[Y]).	&lt;(X,Y) :- send(X,&lt;,[Y]).	=&lt;(X,Y) :- send(X,&lt;=,[Y]).    ')</body><body package="PrologCore">systemPredicatesNo3	"MT - 1 janvier 2019    	Réécriture complète du code de 'is' pour que la sémantique soit celle de SWI Prolog :	le calcul de l'expression que si la valeur de toutes les variables est connue.	Actuellement en Prolog, pourrait avantageusement être déplacée dans le code Smalltalk,	ce qui simplifierait la génération de messages d'erreurs.	"	self systemReconsult: (ReadStream				on: '	+(X,Y,Z) :- send(X,+,[Y],Z).	-(X,Y,Z) :- send(X,-,[Y],Z).	*(X,Y,Z) :- send(X,*,[Y],Z).	//(X,Y,Z) :- send(X,//,[Y],Z).	/(X,Y,Z) :- send(X,/,[Y],Z).	\\(X,Y,Z) :- send(X,\\,[Y],Z).		% Now behavior of "is" is the same as in SWI Prolog. Still in prefix notation.''~is_evaluator~''(R, R) :- number(R), !.''~is_evaluator~''(S, R) :- 	send({[:s | [s functor string asSymbol] on: Error do:				[Error raiseErrorString: ''Evaluation error in predicate is'']				]}, value:, [S], F),	send({[:s | s terms asPrologList]},value:, [S], Args),	send(S, arity, [], A),	''~is_F_evaluator~''(A, F, Args, R).''~is_F_evaluator~''(1, F, [A1], R):-	''~is_evaluator~''(A1, R1),	send({[:a1 :op | [a1 perform: op] on: Error do: 						[Error raiseErrorString: ''Evaluation error in predicate is'']						]}, value:value:, [R1, F], R).''~is_F_evaluator~''(2, F, [A1,A2], R):-	''~is_evaluator~''(A1, R1),	''~is_evaluator~''(A2, R2),	send({[:a1 :op :a2 | [a1 perform: op with: a2] on: Error do: 							[Error raiseErrorString: ''Evaluation error in predicate is'']							]}, value:value:value:, [R1, F, R2], R).is(X, Expr) :- var(X), ''~is_evaluator~''(Expr, X).    ')</body><body package="PrologCore">systemPredicatesNo4        self systemReconsult: (ReadStream on: '	listing :- send(self,userListing,[]).	listing(X) :- send(self,userListing:,[X]).	systemListing :- send(self,systemListing,[]).	systemListing(X) :- send(self,systemListing:,[X]).	consult(X) :- nonvar(X), send(self,consultFile:,[X]).	reconsult(X) :- nonvar(X), send(self,reconsultFile:,[X]).	saving :- send(self,saving,[]).	saving(X) :- send(self,saving:,[X]).	userPredicates(X) :- send(self,userPredicates,[],X).	systemPredicates(X) :- send(self,systemPredicates,[],X).	predicates([X|Y]) :- userPredicates(X), systemPredicates(Y).	functor(T,F,A) :- nonvar(T), !, send(self,functorArityOf:,[T],[F|A]).	functor(T,F,A) :- number(F), !, =(0,A),=(T,F).	functor(T,F,A) :- atom(F), =&lt;(0,A), ''~addvar''([F],A,L), =..(T,L).	''~addvar''(L,0,M) :- !, =(L,M).	''~addvar''(L,NVars,M) :- -(NVars, 1, N), append(L,[FreeV],LV), ''~addvar''(LV,N,M).	arg(Nth,S,T) :- integer(Nth), &lt;(0,Nth), structure(S), =..(S,[F|L]), nth(L,Nth,T).	=..(X,Y) :- send(self,univ:,[[''X''|''Y'']]).	name(X,Y) :- atomic(X), list(Y), !, send(self,symToList:,[X],Y).	name(X,Y) :- atomic(X), !, send(self,symToStr:,[X],Y).	name(X,Y) :- var(X), !, nonvar(Y), send(self, strToSym:,[Y],X).	remove :- send(self,remove,[]).	remove(X) :- send(self,remove:,[X]).	clause(X) :- send(self,clauseSet:,[X]), repeat, send(self,clause:,[X],X).	asserta(X) :- send(self,asserta:,[X]).	assert(X) :- send(self,assertz:,[X]).	assertz(X) :- send(self,assertz:,[X]).	retract(X) :- repeat, send(self,retract:,[X],X).    ')</body><body package="PrologCore">systemPredicatesNo5        self systemReconsult: (ReadStream on: '	call(G) :- G.	not(G) :- G, !, fail.	not(G).	or(X,Y) :- call(X).	or(X,Y) :- call(Y).	and(X,Y) :- call(X), call(Y).    ')</body><body package="PrologCore">systemPredicatesNo6		self systemReconsult: (ReadStream				on: '	write(X) :- send(self,write:,[X]).	nl :- send(self,nl,[]).	tab(X) :- number(X), send(self,tab:,[X]).	clear :- send(self,clear,[]).    ')</body><body package="PrologCore">systemPredicatesNo7        self systemReconsult: (ReadStream on: '	clock(X) :- send({Time},millisecondClockValue,[],X).	verbose(X) :- send(self,verbose:,[X]).	gc :- send(self,gc,[]).	inspect(X) :- send(X,inspect,[]).	spy(X) :- send(self,spy:,[X]).	nospy(X) :- send(self,nospy:,[X]).	trace :- send(self,trace,[]).	notrace :- send(self,notrace,[]).    ')</body><body package="PrologCore">systemPredicatesNo8        self systemReconsult: (ReadStream on: '	append([],X,X).	append([A|X],Y,[A|Z]) :- append(X,Y,Z).	member(X,[X|Y]).	member(X,[Y|Z]) :- member(X,Z).	reverse([],[]).	reverse([H|T],L) :- reverse(T,Z), append(Z,[H],L).	length(X,Y) :- send(self,length:,[X],Y).	nth([X|Y],1,Z) :- !, =(X,Z).	nth([X|Y],N,Z) :- -(N,1,PN), nth(Y,PN,Z).	printlist(L) :- send(self,listPrint:,[L]).	lispAppend(X,Y,Z) :- send(X,append:,[Y],Z).	lispReverse(X,Y) :- send(X,reverse,[],Y).	lispMember(X,Y) :- send(Y,member:,[X],A), \=(A,[]).	lispMember(X,Y,Z) :- send(Y,member:,[X],Z).	lispAssoc(X,Y) :- send(Y,assoc:,[X],A), \=(A,[]).	lispAssoc(X,Y,Z) :- send(Y,assoc:,[X],Z).	lispNconc(X,Y,Z) :- send(X,nconc:,[Y],Z).    ')</body><body package="PrologCore">systemPredicatesNo9        self systemReconsult: (ReadStream on: '	%	%    User System Predicates	%    ')</body></methods><methods><class-id>Prolog.PrologInterpreter</class-id> <category>unification</category><body package="PrologCore">unify: x env: xEnv and: y env: yEnv     | xx yy assoc |    xx := x.    yy := y.    [true]	whileTrue: 	    [xEnv == yEnv ifTrue: [x = y ifTrue: [^true]].	    xx isPrologVariable ifTrue: [(assoc := self binding: xx env: xEnv) ~~ nil		    ifTrue: 			[valueEnv := xEnv.			assoc := assoc cdr.			xx := self fetchValue: assoc car env: assoc cdr.			^self			    unify: xx			    env: valueEnv			    and: yy			    env: yEnv]		    ifFalse: 			[yy isPrologVariable ifTrue: [(assoc := self binding: yy env: yEnv) ~~ nil				ifTrue: 				    [valueEnv := yEnv.				    assoc := assoc cdr.				    yy := self fetchValue: assoc car env: assoc cdr.				    ^self					unify: xx					env: xEnv					and: yy					env: valueEnv]].			self			    bind: xx			    env: xEnv			    and: yy			    env: yEnv.			^true]].	    yy isPrologVariable		ifTrue: 		    [(assoc := self binding: yy env: yEnv) ~~ nil			ifTrue: 			    [valueEnv := yEnv.			    assoc := assoc cdr.			    yy := self fetchValue: assoc car env: assoc cdr.			    ^self				unify: xx				env: xEnv				and: yy				env: valueEnv].		    self			bind: yy			env: yEnv			and: xx			env: xEnv.		    ^true].	    xx consp ifFalse: [^xx = yy].	    yy consp ifFalse: [^yy = xx].	    (self		unify: xx car		env: xEnv		and: yy car		env: yEnv)		ifFalse: [^false].	    xx := xx cdr.	    yy := yy cdr]</body></methods><methods><class-id>Prolog.PrologInterpreter</class-id> <category>accessing</category><body package="PrologCore">textCollector    ^textCollector</body><body package="PrologCore">textCollector: aTextCollector     textCollector := aTextCollector</body></methods><methods><class-id>Prolog.PrologInterpreter</class-id> <category>copying</category><body package="PrologCore">shallowCopy    super shallowCopy.    textValue := nil.    listValue := nil.    predicate := nil</body></methods><methods><class-id>Prolog.PrologInterpreter</class-id> <category>resolve modules</category><body package="PrologCore">back    | array |    backTrack == nil	ifTrue: 	    [status := #fail.	    ^self].    array := backTrack car.    backTrack := backTrack cdr.    clause := array at: 1.    clauseEnv := array at: 2.    queue := array at: 3.    queueEnv := array at: 4.    cutBack := array at: 5.    definition := array at: 6.    array := array at: 7.    self unbindFrom: unbindList to: array.    unbindList := array.    status := #next</body><body package="PrologCore">loop    | structure functor |    clause == nil	ifTrue: 	    [queue == nil		ifTrue: 		    [status := #succ.		    ^self].	    clause := queue car.	    clauseEnv := queueEnv car.	    queue := queue cdr.	    queueEnv := queueEnv cdr.	    cutBack := cutBack cdr.	    status := #loop.	    ^self].    structure := clause car.    structure consp	ifFalse: 	    [structure := PrologStructure functor: structure terms: nil.	    clause car: structure].    functor := structure car.    functor isPrologVariable	ifTrue: 	    [self call: clause car.	    ^self].    functor isBuiltInPredicate	ifTrue: 	    [self builtInPredicate: functor.	    ^self].    definition := userPredicates at: functor ifAbsent: [systemPredicates at: functor		    ifAbsent: 			[status := #back.			^self]].    status := #next</body><body package="PrologCore">next    | definitionEnv saveBackTrack array |    definitionEnv := self nullEnv.    definition cdr == nil	ifTrue: 	    [(self		unify: clause car cdr		env: clauseEnv		and: definition car car cdr		env: definitionEnv)		ifFalse: 		    [status := #back.		    ^self].	    queue := clause cdr cons: queue.	    queueEnv := clauseEnv cons: queueEnv.	    clause := definition car cdr.	    clauseEnv := definitionEnv.	    cutBack := backTrack cons: cutBack.	    status := #loop.	    ^self].    saveBackTrack := backTrack.    array := Array new: 7.    array at: 1 put: clause.    array at: 2 put: clauseEnv.    array at: 3 put: queue.    array at: 4 put: queueEnv.    array at: 5 put: cutBack.    array at: 6 put: definition cdr.    array at: 7 put: unbindList.    backTrack := array cons: saveBackTrack.    (self	unify: clause car cdr	env: clauseEnv	and: definition car car cdr	env: definitionEnv)	ifFalse: 	    [status := #back.	    ^self].    queue := clause cdr cons: queue.    queueEnv := clauseEnv cons: queueEnv.    clause := definition car cdr.    clauseEnv := definitionEnv.    cutBack := saveBackTrack cons: cutBack.    status := #loop</body></methods><methods><class-id>Prolog.PrologInterpreter</class-id> <category>initialize-release</category><body package="PrologCore">initialize    systemPredicates := Dictionary new.    userPredicates := Dictionary new.    tracePredicates := Dictionary new.    textCollector := Transcript.    verbose := false.    self makeSystemPredicates</body></methods><methods><class-id>Prolog.PrologInterpreter class</class-id> <category>examples</category><body package="PrologCore">example01    "PrologInterpreter example01."    self example: '    ?- remove.       % remove all predicates in PrologDataBase.    likes(john,mary).    % assert fact.    likes(john,wine).    % assert fact.    likes(mary,wine).    % assert fact.    likes(mary,john).    % assert fact.    ?- likes(X,Y).	   % question goal.    ?- likes(john,X), likes(mary,X). % question goal.    '</body><body package="PrologCore">example02    "PrologInterpreter example02."    self example: '    ?- remove.       % remove all predicates in PrologDataBase.    on(hen,cat).    on(cat,dog).    on(dog,donkey).    above(X,Y) :- on(X,Y).    above(X,Y) :- on(X,Z), above(Z,Y).	    ?- on(X,dog).    ?- above(X,dog).    '</body><body package="PrologCore">example03    "PrologInterpreter example03"    self example: '    ?- remove.    % remove all predicates in PrologDataBase.    hanoi(N) :-    % This is Hanoi Tower Program.	move(N,left,right,center).	move(0,X,Y,Z) :- !.    move(N,A,B,C) :-	-(N,1,M),	move(M,A,C,B),	inform(A,B),	move(M,C,B,A).    inform(X,Y) :-	write([''move disc from '',X,'' to '',Y]),	nl.    ?- hanoi(3).     % question goal.    '</body><body package="PrologCore">example04	"PrologInterpreter example04."	| string prolog result |	self example: '?- append(X,Y,[a,b,c,d]).'</body><body package="PrologCore">example05    "PrologInterpreter example05."    self example: '    ?- send(123,+,[456],X).   % X := 123 + 456.    '</body><body package="PrologCore">example06    "PrologInterpreter example06."    self example: '    ?- is(X,+(3,4)).    ?- is(X,F(3,4)).    '</body><body package="PrologCore">example: string    ^(PrologInterpreter new) "	textCollector: Transcript;"	refute: string action: 	    [:answer | 	    answer keys asSortedCollection		do: 		    [:s | 		    Transcript show: s.		    Transcript show: ' = '.		    Transcript show: (answer at: s) printPrologString.		    Transcript cr]. false]</body></methods><methods><class-id>Prolog.PrologInterpreter class</class-id> <category>public access</category><body package="PrologCore">refute: stringOrStream     ^self new refute: stringOrStream</body><body package="PrologCore">refute: stringOrStream action: aBlock     ^self new refute: stringOrStream action: aBlock</body></methods><methods><class-id>Prolog.PrologInterpreter class</class-id> <category>instance creation</category><body package="PrologCore">new    ^super new initialize</body></methods><methods><class-id>Prolog.PrologShellInterpreter</class-id> <category>initialize-release</category><body package="PrologShell">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Prolog.PrologShellInterpreter</class-id> <category>system predicates</category><body package="PrologShell">fillDataBase	^(Collection subclasses collect: [:c | c name asString])		do: [:n | self refute: 'subclass("Collection", "' , n , '").']</body><body package="PrologShell">fillDataBaseWithSubclassesOf: class	| lc |	lc := class subclasses.	lc size ~= 0		ifTrue: 			[| nc |			nc := class name asString.			lc do: 					[:sc |					self refute: 'subclass("' , nc , '", "' , sc name asString , '").'.					self fillDataBaseWithSubclassesOf: sc]]</body><body package="PrologShell">prologToSmallTalkString: aProString	"MT 27 décembre 2018 - for read(X)"	^aProString string</body><body package="PrologShell">smallTalkToPrologString: aSmallString	"MT 27 décembre 2018 - for read(X)"	^PrologString fromString: aSmallString</body><body package="PrologShell">tab: aNumber     | spaces |    (aNumber isKindOf: Number)	ifFalse: [^false].    spaces := String new.    aNumber asInteger timesRepeat: [spaces := spaces , '    '].    textCollector show: spaces.    ^true</body></methods><methods><class-id>Prolog.PrologShellInterpreter</class-id> <category>private</category><body package="PrologShell">systemPredicatesNo6	"MT 27 décembre 2018 - read(X) and read(X,M) added."	super systemPredicatesNo6.	self systemReconsult: (ReadStream				on: '	read(X) :- 		send({Dialog}, request:initialAnswer:,[{''Value ?''}, {''''}], S), 		send(self, smallTalkToPrologString:, [S], X).	read(X, M) :- 		send(self, prologToSmallTalkString:, [M], SS),		send({Dialog}, request:initialAnswer:,[SS, {''''}], S), 		send(self, smallTalkToPrologString:, [S], X).    ')</body><body package="PrologShell">systemPredicatesNo9        self systemReconsult: (ReadStream on: '	%	%    User System Predicates	%findall(X,G,L) :-	assert(''~l__FindAll''([])), 	call(G),	''~l__FindAll''(L1),	remove(''~l__FindAll''),	assert(''~l__FindAll''([X | L1])),	fail.findall(X,G,L) :-	''~l__FindAll''(L1),	reverse(L1,L),	remove(''~l__FindAll'').    ')</body></methods><methods><class-id>Prolog.PrologResolveClause</class-id> <category>polymorphism</category><body package="PrologCore">isResolveClause    ^true</body><body package="PrologCore">printPrologOn: aStream     | head body |    head := self head.    body := self body.    aStream nextPutAll: '?- '.    head printPrologOn: aStream.    body ~~ nil	ifTrue: 	    [aStream nextPutAll: ', '.	    body printPrologOn: aStream].    aStream nextPut: $.</body></methods><methods><class-id>Prolog.PrologEditorController</class-id> <category>menu messages</category><body package="PrologShell">accept</body><body package="PrologShell">doIt	super accept</body><body package="PrologShell">explain</body><body package="PrologShell">inspectIt</body><body package="PrologShell">loadBuffer	| dialog file |	dialog := OpenFileDialog new.	dialog		addFileFilter: 'Prolog source (*.pl)' pattern: '*.pl';		addFilterForAllFiles;		fileCondition: #mustBeOld;		defaultDirectory: ObjectMemory imageDirectory asString.	file := dialog select.	file		ifNotNil: 			[model setValue: (Text fromString: file contentsOfEntireFile).			view updateDisplayContents.			lastFileName := file]</body><body package="PrologShell">saveBuffer	| dialog file defDir defName |	defDir := lastFileName isNil				ifTrue: [ObjectMemory imageDirectory]				ifFalse: [lastFileName directory].	defName := lastFileName isNil				ifTrue: ['noname.pl']				ifFalse: [lastFileName tail].	dialog := SaveFileDialog new.	dialog		addFileFilter: 'Prolog source (*.pl)' pattern: '*.pl';		addFilterForAllFiles;		fileCondition: #new;		defaultDirectory: defDir;		defaultFilename: defName.	file := dialog select.	file		ifNotNil: 			[| stream |			stream := file writeStream.			stream nextPutAll: model value string.			stream close.			lastFileName := file]</body></methods><methods><class-id>Prolog.PrologEditorController</class-id> <category>initialize-release</category><body package="PrologShell">initialize	"Initialize a newly created instance. This method must answer the receiver."	lastFileName := nil.	super initialize.	self modifyMenu.	^self</body><body package="PrologShell">modifyMenu	| menu initialMenu saveMenuItem evalMenuItem loadMenuItem |	initialMenu := menuHolder value copy.	initialMenu removeItem: (initialMenu menuItemAt: 1).	menu := Menu new.	evalMenuItem := MenuItem labeled: 'Eval Prolog (Ctrl-D)'.	evalMenuItem value: [super accept].	menu addItem: evalMenuItem.	menu addLine.	saveMenuItem := MenuItem labeled: 'Save as... (Ctrl-S)'.	saveMenuItem value: [self saveBuffer].	menu addItem: saveMenuItem.	loadMenuItem := MenuItem labeled: 'Load from... (Ctrl-O)'.	loadMenuItem value: [self loadBuffer].	menu addItem: loadMenuItem.	menu addPart: initialMenu.	menuHolder value: menu</body></methods><methods><class-id>Prolog.PrologSymbol</class-id> <category>testing</category><body package="PrologCore">isBuiltInPredicate    self isPrologCut ifTrue: [^true].    self isPrologTrue ifTrue: [^true].    self isPrologFail ifTrue: [^true].    self isPrologSend ifTrue: [^true].    self isPrologVar ifTrue: [^true].    ^false</body><body package="PrologCore">isPrologCut    ^self = PrologCut</body><body package="PrologCore">isPrologFail    ^self = PrologFail</body><body package="PrologCore">isPrologSelf    ^self = PrologSelf</body><body package="PrologCore">isPrologSend    ^self = PrologSend</body><body package="PrologCore">isPrologTrue    ^self = PrologTrue</body><body package="PrologCore">isPrologVar    ^self = PrologVar</body></methods><methods><class-id>Prolog.PrologSymbol</class-id> <category>printing</category><body package="PrologCore">printPrologOn: aStream     | flag firstChar i length x |    flag := false.    self do: [:each | (self class charMapAt: each)	    ifFalse: [flag := true]].    string isEmpty	ifTrue: 	    [aStream nextPutAll: ''''.	    aStream nextPutAll: '''']	ifFalse: 	    [firstChar := string at: 1.	    ((firstChar &gt;= $A and: [firstChar &lt;= $Z])		or: [flag])		ifTrue: 		    [aStream nextPutAll: ''''.		    i := 0.		    length := string size.		    [(i := i + 1) &lt;= length]			whileTrue: 			    [aStream nextPut: (x := string at: i).			    x == $' ifTrue: [aStream nextPut: x]].		    aStream nextPutAll: '''']		ifFalse: 		    [i := 0.		    length := string size.		    [(i := i + 1) &lt;= length]			whileTrue: 			    [aStream nextPut: (x := string at: i).			    x == $' ifTrue: [aStream nextPut: x]]]]</body><body package="PrologCore">printPrologOn: aStream level: anInteger     self printPrologOn: aStream</body></methods><methods><class-id>Prolog.PrologSymbol</class-id> <category>accessing</category><body package="PrologCore">arity    ^0</body><body package="PrologCore">functor    ^self</body></methods><methods><class-id>Prolog.PrologSymbol class</class-id> <category>private</category><body package="PrologCore">expect: aString on: aStream    "If aStream contains aString at the current position, then return true and set the position of aStream to the next char of the string.    else return false and rewind the position."    | pos string |    pos := aStream position.    string := String new.    aString size timesRepeat: [	aStream atEnd ifFalse: [string := string , (String with: aStream next)]].    aString = string	ifTrue: [^true]	ifFalse: [	    aStream position: pos.	    ^false]</body></methods><methods><class-id>Prolog.PrologSymbol class</class-id> <category>instance creation</category><body package="PrologCore">install: aString     | symbol key |    symbol := PrologSymbolTable at: aString ifAbsent: [nil].    symbol == nil	ifTrue: 	    [key := self fromString: aString.	    symbol := self fromString: aString.	    PrologSymbolTable at: key put: symbol].    ^symbol</body><body package="PrologCore">readFrom: aStream     | buffer char |    buffer := WriteStream on: (String new: 20).    char := aStream peek.    char == $'	ifTrue: 	    [aStream next.	    	    [char := aStream peek.	    char ~~ nil]		whileTrue: 		    [char = $'			ifTrue: 			    [aStream next.			    char := aStream peek.			    char = $' ifFalse: [^self install: buffer contents]].		    buffer nextPut: aStream next].	self error: 'Syntax error near $'' unmatched $''\-- end of file --' withCRs].    (self expect: '=..' on: aStream)	ifTrue: ["Non standard (or ad hoc) parsing patterns."	    ^self install: '=..'].    [char ~~ nil and: [self charMapAt: char]]	whileTrue: 	    [buffer nextPut: aStream next.	    char := aStream peek].    ^self install: buffer contents</body></methods><methods><class-id>Prolog.PrologSymbol class</class-id> <category>class initialization</category><body package="PrologCore">initialize    "PrologSymbol initialize"    | newMap |    newMap := Array new: 256 withAll: false.    newMap atAll: ($0 asInteger to: $9 asInteger)	put: true.    newMap atAll: ($A asInteger to: $Z asInteger)	put: true.    newMap atAll: ($a asInteger to: $z asInteger)	put: true.    128 to: 256 do: [:i | newMap at: i put: true].    #($+ $- $! $: $* $/ $\ $&gt; $&lt; $= $_) do: [:each | newMap at: each asInteger put: true].    self charMap: newMap.    PrologSymbolTable := Dictionary new.    PrologCut := self install: '!'.    PrologTrue := self install: 'true'.    PrologFail := self install: 'fail'.    PrologSend := self install: 'send'.    PrologVar := self install: 'var'.    PrologSelf := self install: 'self'</body></methods><methods><class-id>Prolog.PrologSymbol class</class-id> <category>constants</category><body package="PrologCore">cut    ^PrologCut</body></methods><methods><class-id>Prolog.PrologShell</class-id> <category>aspects</category><body package="PrologShell">inputText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^inputText isNil		ifTrue:			[inputText := String new asValue]		ifFalse:			[inputText]</body><body package="PrologShell">outputText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^outputText isNil		ifTrue: 			[outputText := TextCollector new  characterLimit: 20000; yourself.			outputText				nextPutAll: 'Prolog output will be here ...';				cr]		ifFalse: [outputText]</body></methods><methods><class-id>Prolog.PrologShell</class-id> <category>evaluation</category><body package="PrologShell">evalBuffer	| text sep sepLine processBlock |	processBlock :=			[sep := true.	"if sep is true, a separation line will be written on output betwenn answers"			sepLine := '============================'.			LastPrologBuffer := inputText value.			text := self getTextToEval.			self outputText clear.						[prologInterpreter refute: text				action: 					[:answer |					answer keys asSortedCollection do: 							[:s |							(prologInterpreter textCollector)								show: s;								show: ' = ';								nextPutAll: (answer at: s) printPrologString;								cr].					sep and: 							[(prologInterpreter textCollector)								nextPutAll: sepLine;								cr].					false]]					on: Error					do: 						[:error |						(prologInterpreter textCollector)							nextPutAll: error messageText;							cr].			(prologInterpreter textCollector)				nextPutAll: '*** Done. ***';				cr.			prologProcess := nil].	prologProcess isNil		ifTrue: 			[prologProcess := processBlock forkAt: Processor userBackgroundPriority.			Processor yield]		ifFalse: 			[prologProcess suspend.			(Dialog confirm: 'Prolog is running. Abort ?')				ifTrue: 					[prologProcess terminate.					prologProcess := nil.					(prologInterpreter textCollector)						nextPutAll: '*** !!!!! Aborted !!!!! ***';						cr]				ifFalse: [prologProcess resume]]</body><body package="PrologShell">evalCell	mustEvalCell := true.	inputText value: (self widgetAt: #TextEditor) displayContents asText</body><body package="PrologShell">getCellContents	"Retourne le contenu de la cellule active (entre des lignes commençant par de multiples %"	| i iStart lines idx doubleCommentArray iFirst iLast |	iStart := (self widgetAt: #TextEditor) startBlock stringIndex.	lines := self arrayOfLinesFrom: inputText value.	idx := 1.	doubleCommentArray := (lines collect: 					[:line |					| a |					a := Array with: idx with: line.					idx := idx + line size + 1.					a])				select: 					[:a |					| line |					line := a at: 2.					line size &gt;= 2 and: [$% = (line at: 1) and: [$% = (line at: 2)]]].	i := 0.		[i + 1 &lt;= doubleCommentArray size		and: [iStart &gt; (doubleCommentArray at: i + 1) first]]			whileTrue: [i := i + 1].	iFirst := i = 0 ifTrue: [1] ifFalse: [(doubleCommentArray at: i) first].	iLast := i = doubleCommentArray size				ifTrue: [inputText value size + 1]				ifFalse: [(doubleCommentArray at: i + 1) first].	^inputText value string copyFrom: iFirst to: iLast - 1</body><body package="PrologShell">getTextToEval	| text iStart iStop |	mustEvalCell		ifTrue: 			[text := self getCellContents.			mustEvalCell := false]		ifFalse: 			[iStart := (self widgetAt: #TextEditor) startBlock stringIndex.			iStop := (self widgetAt: #TextEditor) stopBlock stringIndex.			text := iStart = iStop						ifTrue: [self inputText value]						ifFalse: [self inputText value copyFrom: iStart to: iStop - 1]].	^text</body></methods><methods><class-id>Prolog.PrologShell</class-id> <category>interface opening</category><body package="PrologShell">postBuildWith: aBuilder	| ctr  cmd |	(self widgetAt: #TextEditor) model onChangeSend: #evalBuffer to: self.	ctr := PrologEditorController new.	(self widgetAt: #TextEditor) controller: ctr.	ctr keyboardHook: 			[:ev :ctrl |			| finalEvt |			ev keyValue = #Enter ifTrue: [ev key: Character cr meta: ev metaState].			finalEvt := ev.			(ev keyValue = Character cr and: [ev hasCtrl])				ifTrue: 					[self evalCell.					finalEvt = nil].			cmd := ev asPossibleCommandEvent.			cmd				ifNotNil: 					[(cmd matches: #accept) ifTrue: [ctr saveBuffer].					(cmd matches: #open) ifTrue: [ctr loadBuffer].					finalEvt = nil].			finalEvt]</body></methods><methods><class-id>Prolog.PrologShell</class-id> <category>accessing</category><body package="PrologShell">prologInterpreter	^prologInterpreter		ifNil: [prologInterpreter := PrologShellInterpreter new]</body><body package="PrologShell">prologInterpreter: anObject	prologInterpreter := anObject</body></methods><methods><class-id>Prolog.PrologShell</class-id> <category>initialize-release</category><body package="PrologShell">initialize	super initialize.	prologProcess := nil.	self prologInterpreter textCollector: self outputText.	inputText := LastPrologBuffer asValue.	mustEvalCell := false</body></methods><methods><class-id>Prolog.PrologShell</class-id> <category>private</category><body package="PrologShell">arrayOfLinesFrom: aText	"Answer an array of items derived from the receiver where each item represents a portion of	 the receiver delimited by a 'cr'."	| stream result |	stream := ReadStream on: aText.	result := OrderedCollection new.	[stream atEnd] whileFalse: [result add: (stream upTo: Character cr)].	^ result asArray</body><body package="PrologShell">asArrayOfLines	"Answer an array of items derived from the receiver where each item represents a portion of	 the receiver delimited by a 'cr'."	| stream result |	stream := ReadStream on: self.	result := OrderedCollection new.	[stream atEnd] whileFalse: [result add: (stream upTo: Character cr)].	^ result asArray</body></methods><methods><class-id>Prolog.PrologShell class</class-id> <category>instance creation</category><body package="PrologShell">openWith: aPrologInterpreter	| ps |	ps := self basicNew.	ps		prologInterpreter: aPrologInterpreter;		initialize.	^self openOn: ps</body></methods><methods><class-id>Prolog.PrologBody</class-id> <category>printing</category><body package="PrologCore">prettyPrintPrologOn: aStream     | list |    list := self.    aStream cr; tab.    [list cdr consp]	whileTrue: 	    [list ~~ self		ifTrue: 		    [aStream nextPutAll: ', '.		    aStream cr; tab].	    list car printPrologOn: aStream.	    list := list cdr].    list ~~ self	ifTrue: 	    [aStream nextPutAll: ', '.	    aStream cr; tab].    list car printPrologOn: aStream</body><body package="PrologCore">printPrologOn: aStream     | list |    list := self.    [list cdr consp]	whileTrue: 	    [list ~~ self ifTrue: [aStream nextPutAll: ', '].	    list car printPrologOn: aStream.	    list := list cdr].    list ~~ self ifTrue: [aStream nextPutAll: ', '].    list car printPrologOn: aStream</body><body package="PrologCore">printPrologOn: aStream level: anInteger    self printPrologOn: aStream</body></methods><methods><class-id>Prolog.PrologBody</class-id> <category>private</category><body package="PrologCore">fromList: aPrologDotPair     ^self fromReverseList: aPrologDotPair reverse</body><body package="PrologCore">fromReverseList: aPrologDotPair     | list body mark |    list := aPrologDotPair.    body := nil.    [list consp]	whileTrue: 	    [body == nil		ifTrue: [body := mark := self class structure: list car next: body]		ifFalse: [body := self class structure: list car next: body].	    list := list cdr].    mark cdr: list.    ^body</body><body package="PrologCore">structure: aPrologStructure next: link     carPart := aPrologStructure.    cdrPart := link</body></methods><methods><class-id>Prolog.PrologBody class</class-id> <category>instance creation</category><body package="PrologCore">fromList: aPrologDotPair     aPrologDotPair consp ifFalse: [^aPrologDotPair].    ^super new fromList: aPrologDotPair</body><body package="PrologCore">fromReverseList: aPrologDotPair     aPrologDotPair consp ifFalse: [^aPrologDotPair].    ^super new fromReverseList: aPrologDotPair</body><body package="PrologCore">structure: aPrologStructure next: link     ^super new structure: aPrologStructure next: link</body></methods><methods><class-id>Prolog.PrologScanner</class-id> <category>scanning</category><body package="PrologCore">multiChar: type     self perform: type</body><body package="PrologCore">nextToken    | char |    mark := source position.    char := self peekChar.    tokenType := self tableAt: char asInteger.    [tokenType == #xDelimiter]	whileTrue: 	    [self nextChar.	    char := self peekChar.	    tokenType := self tableAt: char asInteger].    (tokenType at: 1) = $x	ifTrue:[self multiChar: tokenType]	ifFalse:[self singleChar: tokenType].    ^token</body><body package="PrologCore">singleChar: type     self nextChar.    token := type.    tokenType == #leftBrace ifFalse: [^self].    tokenType := #object.    token := PrologObject readFrom: source</body><body package="PrologCore">unNextToken    source position: mark</body><body package="PrologCore">xBinary    self error: 'Syntax error ' , source peek printString , '\' withCRs , source upToEnd</body><body package="PrologCore">xColon    | char |    source next.    char := source peek.    char = $-	ifTrue: 	    [tokenType := #neck.	    self singleChar: tokenType]	ifFalse: 	    [self unNextToken.	    tokenType := #symbol.	    token := PrologSymbol readFrom: source]</body><body package="PrologCore">xComment    | char |    [(char := self nextChar) = Character lf]	whileFalse: [char == endChar		ifTrue: 		    [tokenType := #eof.		    ^self]].    self nextToken</body><body package="PrologCore">xDigit    tokenType := #number.    token := Number readFrom: source</body><body package="PrologCore">xDollar    self xBinary</body><body package="PrologCore">xDoubleQuote    tokenType := #string.    token := PrologString readFrom: source</body><body package="PrologCore">xSign    | char sign |    sign := self nextChar.    char := self peekChar.    char isDigit	ifTrue: 	    [tokenType := #number.	    token := Number readFrom: source.	    sign == $- ifTrue: [token := token negated]]	ifFalse: 	    [self unNextChar.	    tokenType := #symbol.	    token := PrologSymbol readFrom: source]</body><body package="PrologCore">xSingleQuote    tokenType := #symbol.    token := PrologSymbol readFrom: source</body><body package="PrologCore">xSymbol    tokenType := #symbol.    token := PrologSymbol readFrom: source</body><body package="PrologCore">xVariable    tokenType := #variable.    token := PrologVariable readFrom: source</body></methods><methods><class-id>Prolog.PrologScanner</class-id> <category>private</category><body package="PrologCore">nextChar    | char |    source atEnd ifTrue: [ ^endChar ].    char := source next.    char = Character cr	ifTrue: 	    [char := Character lf. source peekFor: char].    ^char</body><body package="PrologCore">peekChar    | char |    char := source peek.    char = Character cr ifTrue: [char := Character lf].    char == nil ifTrue: [char := endChar].    ^char</body><body package="PrologCore">unNextChar    source skip: -1</body></methods><methods><class-id>Prolog.PrologScanner</class-id> <category>initialize-release</category><body package="PrologCore">initScanner    endChar := EndChar</body><body package="PrologCore">on: inputStream     source := inputStream.    mark := source position</body></methods><methods><class-id>Prolog.PrologScanner</class-id> <category>accessing</category><body package="PrologCore">tableAt: char    | index |    index := char asInteger.    ^index = 0	ifFalse: [ScanningTable at: index]	ifTrue: [#xDelimiter]</body></methods><methods><class-id>Prolog.PrologScanner</class-id> <category>error handling</category><body package="PrologCore">error: labelString with: contentsString    "(PrologScanner new) error: 'error' with: 'show must go on'."    | handler |    self error: labelString, ' ', contentsString</body></methods><methods><class-id>Prolog.PrologScanner class</class-id> <category>class initialization</category><body package="PrologCore">initialize    "PrologScanner initialize"    | newTable |    newTable := Array new: 256 withAll: #xBinary.    newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter.    newTable atAll: ($0 asInteger to: $9 asInteger) put: #xDigit.    newTable atAll: ($A asInteger to: $Z asInteger) put: #xVariable.    newTable at: $~ asInteger put: #xVariable.    newTable atAll: ($a asInteger to: $z asInteger) put: #xSymbol.    128 to: 256 do: [:i | newTable at: i put: #xSymbol].    #($! $: $* $/ $\ $&gt; $&lt; $= $_) do: [:each | newTable at: each asInteger put: #xSymbol].    newTable at: $^ asInteger put: #eof.    newTable at: $" asInteger put: #xDoubleQuote.    newTable at: $$ asInteger put: #xDollar.    newTable at: $' asInteger put: #xSingleQuote.    newTable at: $( asInteger put: #leftParenthesis.    newTable at: $) asInteger put: #rightParenthesis.    newTable at: $. asInteger put: #period.    newTable at: $: asInteger put: #xColon.    newTable at: $? asInteger put: #xColon.    newTable at: $; asInteger put: #semicolon.    newTable at: $[ asInteger put: #leftBracket.    newTable at: $] asInteger put: #rightBracket.    newTable at: ${ asInteger put: #leftBrace.    newTable at: $} asInteger put: #rightBrace.    newTable at: $, asInteger put: #comma.    newTable at: $| asInteger put: #verticalBar.    newTable at: $+ asInteger put: #xSign.    newTable at: $- asInteger put: #xSign.    newTable at: $% asInteger put: #xComment.    ScanningTable := newTable.    EndChar := $^</body></methods><methods><class-id>Prolog.PrologScanner class</class-id> <category>instance creation</category><body package="PrologCore">new    ^super new initScanner</body></methods><methods><class-id>Prolog.PrologTerms</class-id> <category>private</category><body package="PrologCore">fromList: aPrologDotPair     ^self fromReverseList: aPrologDotPair reverse</body><body package="PrologCore">fromReverseList: aPrologDotPair     | list terms mark |    list := aPrologDotPair.    terms := nil.    [list consp]	whileTrue: 	    [terms == nil		ifTrue: [terms := mark := self class term: list car next: terms]		ifFalse: [terms := self class term: list car next: terms].	    list := list cdr].    mark cdr: list.    ^terms</body><body package="PrologCore">term: anObject next: link     carPart := anObject.    cdrPart := link</body></methods><methods><class-id>Prolog.PrologTerms</class-id> <category>printing</category><body package="PrologCore">printPrologOn: aStream     | list |    aStream nextPut: $(.    list := self.    [list cdr consp]	whileTrue: 	    [list ~~ self ifTrue: [aStream nextPut: $,].	    list car printPrologOn: aStream.	    list := list cdr].    list ~~ self ifTrue: [aStream nextPut: $,].    list car printPrologOn: aStream.    list cdr isNil	ifTrue: [aStream nextPut: $)]	ifFalse:	    [aStream nextPut: $|.	    list cdr printPrologOn: aStream.	    aStream nextPut: $)]</body><body package="PrologCore">printPrologOn: aStream level: anInteger    self printPrologOn: aStream</body></methods><methods><class-id>Prolog.PrologTerms class</class-id> <category>instance creation</category><body package="PrologCore">fromList: aPrologDotPair     ^super new fromList: aPrologDotPair</body><body package="PrologCore">fromReverseList: aPrologDotPair     ^super new fromReverseList: aPrologDotPair</body><body package="PrologCore">term: term next: link     ^super new term: term next: link</body></methods><methods><class-id>Prolog.PrologObject</class-id> <category>printing</category><body package="PrologCore">printOn: aStream     aStream nextPutAll: self class printString.    aStream nextPutAll: '('.    aStream nextPutAll: self object printString.    aStream nextPutAll: ')'</body><body package="PrologCore">printPrologOn: aStream     aStream nextPut: ${.    aStream nextPutAll: self source.    aStream nextPut: $}</body><body package="PrologCore">printPrologOn: aStream level: anInteger    self printPrologOn: aStream</body></methods><methods><class-id>Prolog.PrologObject</class-id> <category>accessing</category><body package="PrologCore">object    ^object</body><body package="PrologCore">object: anObject    object := anObject</body><body package="PrologCore">source    ^source</body><body package="PrologCore">source: aString    source := aString</body></methods><methods><class-id>Prolog.PrologObject</class-id> <category>testing</category><body package="PrologCore">= anObject     anObject class = self class ifFalse: [^false].    ^self object = anObject object</body></methods><methods><class-id>Prolog.PrologObject</class-id> <category>private</category><body package="PrologCore">source: aString object: anObject     self source: aString.    self object: anObject</body></methods><methods><class-id>Prolog.PrologObject class</class-id> <category>instance creation</category><body package="PrologCore">readFrom: aStream     | buffer char |    buffer := WriteStream on: (String new: 20).        [char := aStream next.    char = $}]	whileFalse: 	    [char == nil ifTrue: [self error:		    'Syntax error near ${ unmatched $}\-- end of file --' withCRs].	    buffer nextPut: char].    ^buffer contents</body><body package="PrologCore">source: aString object: anObject     ^super new source: aString object: anObject</body></methods><methods><class-id>Prolog.PrologParser</class-id> <category>scan</category><body package="PrologCore">scan    source atEnd ifTrue: [^#eof].    self nextToken.    tokenType == #eof ifTrue: [^#eof].    tokenType == #neck ifTrue: [^self scanClause: PrologResolveClause]. "resolve clause"    self unNextToken.    ^self scanClause: PrologClause</body><body package="PrologCore">scanBody    | list |    list := nil.    [tokenType ~~ #eof]	whileTrue: 	    [list := self scanStructure cons: list.	    self nextToken.	    tokenType == #rightParenthesis ifTrue: [^PrologBody fromReverseList: list].	    tokenType == #period ifTrue: [^PrologBody fromReverseList: list].	    tokenType ~~ #comma ifTrue: [failBlock value: 'Syntax error']].    failBlock value: 'Unexpected eof'</body><body package="PrologCore">scanClause: class    | head |    head := self scanStructure.    self nextToken.    tokenType == #neck ifTrue: [^class head: head body: self scanBody].    tokenType == #comma ifTrue: [^class head: head body: self scanBody].    tokenType == #period ifTrue: [^class head: head body: nil].    tokenType == #rightParenthesis ifTrue: [^class head: head body: nil].    self unNextToken.    failBlock value: 'Syntax error'</body><body package="PrologCore">scanExpression    | symbol |    self nextToken.    (tokenType == #eof or: [tokenType == #period])	ifTrue: [^nil].    tokenType == #number ifTrue: [^token].    tokenType == #string ifTrue: [^token].    tokenType == #object ifTrue: [^PrologObject source: token object: (self compileAndEvaluate: token)].    tokenType == #leftBracket ifTrue: [^self scanList].    tokenType == #leftParenthesis ifTrue: [^self scanClause: PrologClause].    (tokenType == #symbol or: [tokenType == #variable])	ifTrue: 	    [symbol := token.	    self nextToken.	    tokenType == #leftParenthesis		ifTrue: 		    [self unNextToken.		    self unNextToken.		    ^self scanStructure]		ifFalse: 		    [self unNextToken.		    ^symbol]].    self unNextToken.    failBlock value: 'Syntax error'</body><body package="PrologCore">scanList    | expression |    self nextToken.    tokenType == #comma ifTrue: [self nextToken].    tokenType == #neck ifTrue: [self nextToken].    tokenType == #rightBracket ifTrue: [^nil].    tokenType == #leftBracket ifTrue: [^self scanList cons: self scanList].    tokenType == #verticalBar	ifTrue: 	    [expression := self scanExpression.	    self nextToken.	    tokenType == #rightBracket		ifTrue: [^expression]		ifFalse: [failBlock value: 'Syntax error']].    self unNextToken.    expression := self scanExpression.    ^expression cons: self scanList</body><body package="PrologCore">scanStructure    | functor terms |    functor := self nextToken.    (tokenType == #symbol or: [tokenType == #variable])	ifTrue: 	    [terms := self scanTerms.	    ^PrologStructure functor: functor terms: terms].    failBlock value: 'Syntax error'</body><body package="PrologCore">scanTerms    | list |    self nextToken.    tokenType == #leftParenthesis	ifTrue: 	    [self nextToken.	    (tokenType == #verticalBar or: [tokenType == #rightParenthesis])		ifTrue:		    [tokenType == #rightParenthesis			ifTrue: [^nil].		    list := self scanExpression.		    self nextToken.		    tokenType == #rightParenthesis			ifTrue: [^list]			ifFalse: [failBlock value: 'Syntax error']]		ifFalse: [self unNextToken].	    list := nil.	    [tokenType ~~ #eof]		whileTrue: 		    [list := self scanExpression cons: list.		    self nextToken.		    token == #rightParenthesis ifTrue: [^PrologTerms fromReverseList: list].		    tokenType == #verticalBar			ifTrue:			    [list := list reverse.			    list := list nconc: self scanExpression.			    self nextToken.			    tokenType == #rightParenthesis				ifTrue: [^PrologTerms fromList: list]				ifFalse: [failBlock value: 'Syntax error']].		    tokenType ~~ #comma ifTrue: [failBlock value: 'Syntax error']].	    failBlock value: 'Unexpected eof']	ifFalse: 	    [self unNextToken.	    ^nil]</body></methods><methods><class-id>Prolog.PrologParser</class-id> <category>private</category><body package="PrologCore">compileAndEvaluate: string     ^Object readFromString: string</body><body package="PrologCore">init: sourceStream ifFail: aBlock     super on: sourceStream.    failBlock := aBlock.    PrologVariable setZero</body></methods><methods><class-id>Prolog.PrologParser</class-id> <category>parsing</category><body package="PrologCore">parse: sourceStream     | label string |    ^self parse: sourceStream	ifFail: 	    [:errorMessage | 	    label := errorMessage , ' near ' , token printString.	    string := source upToEnd.	    string size &gt; 100 ifTrue: [string := string copyFrom: 1 to: 100].	    self error: label with: (string = ''			ifTrue: ['-- end of file --']			ifFalse: ['--&gt; ' , string])]</body><body package="PrologCore">parse: sourceStream ifFail: aBlock    | result |    self init: sourceStream ifFail: aBlock.    result := self scan.    ^result</body></methods><methods><class-id>Prolog.PrologParser</class-id> <category>scanning</category><body package="PrologCore">nextToken    prevMark := mark.    prevToken := token.    prevTokenType := tokenType.    ^super nextToken</body><body package="PrologCore">unNextToken    super unNextToken.    mark := prevMark.    token := prevToken.    tokenType := prevTokenType</body></methods><methods><class-id>Prolog.PrologStructure</class-id> <category>printing</category><body package="PrologCore">printPrologOn: aStream     | functor terms |    functor := self functor.    terms := self terms.    functor printPrologOn: aStream.    terms == nil	ifFalse:	    [(terms consp)		ifTrue: [terms printPrologOn: aStream]		ifFalse:		    [aStream nextPutAll: '(|'.		    terms printPrologOn: aStream.		    aStream nextPut: $)]]</body><body package="PrologCore">printPrologOn: aStream level: anInteger    self printPrologOn: aStream</body></methods><methods><class-id>Prolog.PrologStructure</class-id> <category>accessing</category><body package="PrologCore">arity    ^self terms length</body><body package="PrologCore">functor    ^carPart</body><body package="PrologCore">functor: aPrologSymbol     carPart := aPrologSymbol</body><body package="PrologCore">nthTerm: anInteger     ^cdrPart nth: anInteger</body><body package="PrologCore">terms    ^cdrPart</body><body package="PrologCore">terms: aPrologTerms     cdrPart := aPrologTerms</body></methods><methods><class-id>Prolog.PrologStructure</class-id> <category>functions</category><body package="PrologCore">structureList    "disassemble prolog structure of myself into a list."    ^(self functor) cons: self terms asPrologList</body></methods><methods><class-id>Prolog.PrologStructure</class-id> <category>private</category><body package="PrologCore">functor: aPrologSymbol terms: aPrologTerms     self functor: aPrologSymbol.    self terms: aPrologTerms</body></methods><methods><class-id>Prolog.PrologStructure class</class-id> <category>instance creation</category><body package="PrologCore">functor: aPrologSymbol terms: aPrologTerms     ^super new functor: aPrologSymbol terms: aPrologTerms</body></methods><methods><class-id>Core.Object</class-id> <category>prolog</category><body package="PrologCore">car    self == nil ifTrue: [^nil].    self error: 'send message car to atom'</body><body package="PrologCore">cdr    self == nil ifTrue: [^nil].    self error: 'send message cdr to atom'</body><body package="PrologCore">cons: anObject     ^Prolog.PrologList car: self cdr: anObject</body><body package="PrologCore">consp    ^false</body><body package="PrologCore">isPrologEntity    self == nil ifTrue: [^true].    ^self isKindOf: Number</body><body package="PrologCore">isPrologVariable    ^false</body><body package="PrologCore">printPrologOn: aStream     self == nil	ifTrue: 	    [aStream nextPutAll: '[]'.	    ^self].    (self isKindOf: Number)	ifTrue: 	    [self printOn: aStream.	    ^self].    aStream nextPut: ${.    self printOn: aStream.    aStream nextPut: $}</body><body package="PrologCore">printPrologOn: aStream level: anInteger     self printPrologOn: aStream</body><body package="PrologCore">printPrologString    | aStream |    aStream := WriteStream on: (String new: 20).    self printPrologOn: aStream.    ^aStream contents</body></methods><methods><class-id>Prolog.PrologShell class</class-id> <category>interface specs</category><body package="PrologShell">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Prolog Shell' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 669 213 1252 868 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 2 0 0 1 -249 1 ) 					#name: #TextEditor 					#model: #inputText 					#isReadOnly: false 					#tabRequiresControl: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -248 1 0 1 -240 1 ) 					#name: #ResizingSplitter1 					#flags: 8 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 7167 7167 ) ) 					#horizontal: true 					#minAboveSize: 80 					#minBelowSize: 80 					#aboveWidgets: 'TextEditor' 					#belowWidgets: 'TextConsole' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -241 1 0 1 0 1 ) 					#name: #TextConsole 					#model: #outputText 					#isReadOnly: true 					#tabRequiresControl: true ) ) ) )</body></methods><initialize><class-id>Prolog.PrologList</class-id></initialize><initialize><class-id>Prolog.PrologVariable</class-id></initialize><initialize><class-id>Prolog.PrologSymbol</class-id></initialize><initialize><class-id>Prolog.PrologScanner</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>TextEditorController</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>beginTypeInIndex anchorIndex emphasisHere dispatchTable charComposer textHasChanged feelPolicy supportCodeEditingFeels localMenuItems extendingDown keyboardHook readOnly accepted autoAccept continuousAccept tabMeansNextField tabRequiresControl dispatcher selectable maxChars nextUndoBlock currentUndo </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class></st-source>